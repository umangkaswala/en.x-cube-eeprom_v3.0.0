###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         09/Dec/2021  10:22:17
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Middlewares\ST\EEPROM_Emul\Core\eeprom_emul.c
#    Command line      =
#        -f C:\Users\dekaswum\AppData\Local\Temp\EWE109.tmp
#        (D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Middlewares\ST\EEPROM_Emul\Core\eeprom_emul.c
#        -D USE_HAL_DRIVER -D STM32G071xx --preprocess=s
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\NUCLEO-G071RB\List
#        -lC
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\NUCLEO-G071RB\List
#        -lA
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\NUCLEO-G071RB\List
#        -o
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\NUCLEO-G071RB\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\..\..\Inc\\
#        -I
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32G0xx\Include\\
#        -I
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\..\..\..\..\..\Drivers\STM32G0xx_HAL_Driver\Inc\\
#        -I
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\..\..\..\..\..\Drivers\BSP\STM32G0xx_Nucleo\\
#        -I
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\..\..\..\..\..\Middlewares\ST\EEPROM_Emul\Core\\
#        -I
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\..\..\..\..\..\Middlewares\ST\EEPROM_Emul\Porting\STM32G0\\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\CMSIS\Core\Include\\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\CMSIS\DSP\Include\\")
#    Locale            =  C
#    List file         =
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\NUCLEO-G071RB\List\eeprom_emul.lst
#    Object file       =
#        D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Projects\STM32G0\EEPROM_Emul\EWARM\NUCLEO-G071RB\NUCLEO-G071RB\Obj\eeprom_emul.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Projects\IO-Link_Implementation\EEPROM\en.x-cube-eeprom_v3.0.0\X-CUBE-EEPROM_V3.0.0\Middlewares\ST\EEPROM_Emul\Core\eeprom_emul.c
      1          /**
      2            ******************************************************************************
      3            * @file    EEPROM_Emul/Core/eeprom_emul.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides all the EEPROM emulation firmware functions.
      6            @verbatim
      7            ==============================================================================
      8                                  ##### How to use this driver #####
      9            ==============================================================================
     10              [..]
     11                This driver provides functions to initialize EEPROM emulation, to read and
     12                write EEPROM variables, and to cleanup FLASH pages used by EEPROM emulation.
     13          
     14                (#) EEPROM emulation initialization functions:
     15                     (++) Format the FLASH pages used by EEPROM emulation using EE_Format().
     16                          This function is optionally used, it can be called the very first
     17                          time EEPROM emulation is used, to prepare FLASH pages for EEPROM
     18                          emulation with empty EEPROM variables. It can also be called at
     19                          any time, to flush all EEPROM variables.
     20                     (++) Initialize EEPROM emulation, and restore the FLASH pages used by
     21                          EEPROM emulation to a known good state in case of power loss
     22                          using EE_Init(). It must be performed at system start up.
     23          
     24                (#) EEPROM variables access functions:
     25                     (++) Write EEPROM variable using EE_WriteVariableXbits() functions
     26                          A Clean Up request can be raised as return parameter in case
     27                          FLASH pages used by EEPROM emulation, are full.
     28                     (++) Read EEPROM variable using EE_ReadVariableXbits() functions
     29          
     30                (#) Clean up functions of FLASH pages, used by EEPROM emulation:
     31                     (++) There Two modes of erasing:
     32                      (+++) Polling mode using EE_CleanUp() function
     33                      (+++) Interrupt mode using EE_CleanUp_IT() function
     34                     (++) Callback function called when the clean up operation in interrupt
     35                          mode, is finished: EE_EndOfCleanup_UserCallback()
     36          
     37            @endverbatim
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
     42            * All rights reserved.</center></h2>
     43            *
     44            * This software component is licensed by ST under BSD 3-Clause license,
     45            * the "License"; You may not use this file except in compliance with the
     46            * License. You may obtain a copy of the License at:
     47            *                        opensource.org/licenses/BSD-3-Clause
     48            *
     49            ******************************************************************************
     50            */
     51          
     52          /* Includes ------------------------------------------------------------------*/
     53          #include "eeprom_emul.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_ResetCRCCalculationUnit(CRC_TypeDef *)
   \                     LL_CRC_ResetCRCCalculationUnit: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x430A             ORRS     R2,R2,R1
   \        0x6   0x6082             STR      R2,[R0, #+8]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetPolynomialSize(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetPolynomialSize: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x2318             MOVS     R3,#+24
   \        0x4   0x439A             BICS     R2,R2,R3
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6082             STR      R2,[R0, #+8]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetPolynomialCoef(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetPolynomialCoef: (+1)
   \        0x0   0x6141             STR      R1,[R0, #+20]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_FeedData32(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_FeedData32: (+1)
   \        0x0   0x6001             STR      R1,[R0, #+0]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_FeedData16(CRC_TypeDef *, uint16_t)
   \                     LL_CRC_FeedData16: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   \        0x2   0x8011             STRH     R1,[R2, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint16_t LL_CRC_ReadData16(CRC_TypeDef *)
   \                     LL_CRC_ReadData16: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0xB280             UXTH     R0,R0
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_AHB1_GRP1_EnableClock(uint32_t)
   \                     LL_AHB1_GRP1_EnableClock: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x....             LDR      R1,??DataTable1  ;; 0x40021038
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x4302             ORRS     R2,R2,R0
   \        0x8   0x600A             STR      R2,[R1, #+0]
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x4001             ANDS     R1,R1,R0
   \        0xE   0x9100             STR      R1,[SP, #+0]
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR               ;; return
     54          
     55          /** @defgroup EEPROM_Emulation EEPROM_Emulation
     56            * @{
     57            */
     58          
     59          /* Private define -----------------------------------------------------------*/
     60          #ifdef DUALCORE_FLASH_SHARING
     61          #define HSEM_PROCESS_1 12U /* Number taken randomly to identify the process locking a semaphore in the driver context */
     62          #endif
     63          /* Private typedef -----------------------------------------------------------*/
     64          /** @defgroup EEPROM_Private_Structures EEPROM Private Structures
     65            * @{
     66            */
     67          
     68          /**
     69            * @brief  EE Find Type structure definition.
     70            */
     71          /* Type of find requested :
     72                 READ  --> page in active state
     73                 WRITE --> page in receive state or active state
     74                 ERASE --> page in erased state */
     75          typedef enum {
     76             FIND_READ_PAGE,
     77             FIND_WRITE_PAGE,
     78             FIND_ERASE_PAGE
     79          } EE_Find_type;
     80          
     81          /**
     82            * @brief  EE State Type structure definition.
     83            */
     84          /* Type of state requested :
     85                 ERASED  --> page is erased
     86                 RECEIVE --> page used during data transfer when no more space available in the system
     87                 ACTIVE  --> page contains valid data and is not full
     88                 VALID   --> page contains valid data and is full
     89                 ERASING --> page used during transfer, should be erased after transfer
     90                 INVALID --> page invalid state */
     91          typedef enum {
     92             STATE_PAGE_ERASED,
     93             STATE_PAGE_RECEIVE,
     94             STATE_PAGE_ACTIVE,
     95             STATE_PAGE_VALID,
     96             STATE_PAGE_ERASING,
     97             STATE_PAGE_INVALID
     98          } EE_State_type;
     99          
    100          /**
    101            * @brief  EE Transfer Type structure definition.
    102            */
    103          /* Definition of the different type of page transfer
    104                  NORMAL  -> copy data page source to page destination
    105                  RECOVER -> resume page transfer that has been interrupted */
    106          typedef enum {
    107            EE_TRANSFER_NORMAL,
    108            EE_TRANSFER_RECOVER
    109          } EE_Transfer_type;
    110          
    111          /**
    112            * @brief  EE State Reliability structure definition.
    113            */
    114          /* Reliability of page state:
    115                  RELIABLE  -> header of page is not corrupted, state is reliable
    116                  CORRUPTED -> header of page is corrupted, state is corrupted */
    117          typedef enum {
    118            STATE_RELIABLE,
    119            STATE_CORRUPTED
    120          } EE_State_Reliability;
    121          
    122          /**
    123            * @}
    124            */
    125          
    126          /* Private variables ---------------------------------------------------------*/
    127          /** @defgroup EEPROM_Private_Variables EEPROM Private Variables
    128            * @{
    129            */
    130          
    131          /* Global variables used to store eeprom status */

   \                                 In section .bss, align 2
    132          uint16_t uhNbWrittenElements = 0U;                  /*!< Nb of elements written in valid and active pages */
   \                     uhNbWrittenElements:
   \        0x0                      DS8 2

   \                                 In section .bss, align 1
    133          uint8_t ubCurrentActivePage = 0U;                   /*!< Current active page (can be active or receive state) */
   \                     ubCurrentActivePage:
   \        0x0                      DS8 1

   \                                 In section .data, align 4
    134          uint32_t uwAddressNextWrite = PAGE_HEADER_SIZE;     /*!< Initialize write position just after page header */
   \                     uwAddressNextWrite:
   \        0x0   0x0000'0020        DC32 32
    135              
    136          /* During the cleanup phase in EE_Init, AddressRead is the address being read */ 

   \                                 In section .bss, align 4
    137          __IO uint32_t AddressRead = 0;
   \                     AddressRead:
   \        0x0                      DS8 4
    138          /* Flag equal to 1 when the cleanup phase is in progress, 0 if not */

   \                                 In section .bss, align 1
    139          __IO uint8_t CleanupPhase = 0;
   \                     CleanupPhase:
   \        0x0                      DS8 1
    140          
    141          
    142          /**
    143            * @}
    144            */
    145          
    146          /* Private function prototypes -----------------------------------------------*/
    147          /** @defgroup EEPROM_Private_Functions EEPROM Private Functions
    148            * @{
    149            */
    150          
    151          static EE_Status ReadVariable(uint16_t VirtAddress, EE_DATA_TYPE* pData);
    152          static EE_Status WriteVariable(uint16_t VirtAddress, EE_DATA_TYPE Data);
    153          static EE_Status VerifyPageFullyErased(uint32_t Address, uint32_t PageSize);
    154          static uint32_t FindPage(EE_Find_type Operation);
    155          static EE_Status PagesTransfer(uint16_t VirtAddress, EE_DATA_TYPE Data, EE_Transfer_type type);
    156          #ifdef DUALCORE_FLASH_SHARING
    157          static EE_Status VerifyPagesFullWriteVariable(uint16_t VirtAddress, EE_DATA_TYPE Data, EE_Write_type Write_type);
    158          #else
    159          static EE_Status VerifyPagesFullWriteVariable(uint16_t VirtAddress, EE_DATA_TYPE Data);
    160          #endif
    161          static EE_Status SetPageState(uint32_t Page, EE_State_type State);
    162          static EE_State_type GetPageState(uint32_t Address);
    163          void ConfigureCrc(void);
    164          uint16_t CalculateCrc(EE_DATA_TYPE Data, uint16_t VirtAddress);
    165          
    166          /**
    167            * @}
    168            */
    169          
    170          /* Exported functions -------------------------------------------------------*/
    171          /** @addtogroup EEPROM_Exported_Functions
    172            * @{
    173            */
    174          
    175          /**
    176            * @brief  Restore the pages to a known good state in case of power loss.
    177            *         If a page is in RECEIVE state, resume transfer.
    178            *         Then if some pages are ERASING state, erase these pages.
    179            * @param  EraseType: Type of erase to apply on page requiring to be erased.
    180            *         This parameter can be one of the following values:
    181            *          @arg @ref EE_FORCED_ERASE      pages to erase are erased unconditionnally
    182            *          @arg @ref EE_CONDITIONAL_ERASE pages to erase are erased only if not fully erased
    183            * @retval EE_Status
    184            *           - EE_OK in case of success
    185            *           - EE error code in case of error
    186            */

   \                                 In section .text, align 4, keep-with-next
    187          EE_Status EE_Init(EE_Erase_type EraseType)
    188          {
   \                     EE_Init: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB08E             SUB      SP,SP,#+56
    189            EE_State_type pagestatus = STATE_PAGE_INVALID;
   \        0x4   0x2005             MOVS     R0,#+5
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7208             STRB     R0,[R1, #+8]
    190            uint32_t page = 0U, pageaddress = 0U, varidx = 0U,
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9003             STR      R0,[SP, #+12]
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9004             STR      R0,[SP, #+16]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9005             STR      R0,[SP, #+20]
    191                     nbactivepage = 0U, nbactivereceivepage = 0U, nbvalidpage = 0U,
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9007             STR      R0,[SP, #+28]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x900A             STR      R0,[SP, #+40]
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x9009             STR      R0,[SP, #+36]
    192                     lastvalidpage = 0U, firstvalidpage = 0U,
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9008             STR      R0,[SP, #+32]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x9006             STR      R0,[SP, #+24]
    193                     recoverytransfer = 0U;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x900B             STR      R0,[SP, #+44]
    194            EE_ELEMENT_TYPE addressvalue = 0U;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0xAA0C             ADD      R2,SP,#+48
   \       0x34   0xC203             STM      R2!,{R0,R1}
   \       0x36   0x3A08             SUBS     R2,R2,#+8
    195            EE_State_Reliability pagestate = STATE_RELIABLE;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x7248             STRB     R0,[R1, #+9]
    196            EE_Status status = EE_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x4669             MOV      R1,SP
   \       0x42   0x8148             STRH     R0,[R1, #+10]
    197          
    198            /* Check if the configuration is 128-bits bank or 2*64-bits bank */
    199            if (FI_CheckBankConfig() != EE_OK)
   \       0x44   0x....'....        BL       FI_CheckBankConfig
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD001             BEQ      ??EE_Init_2
    200            {
    201              return EE_INVALID_BANK_CFG;
   \       0x4C   0x200E             MOVS     R0,#+14
   \       0x4E   0xE3D7             B        ??EE_Init_3
    202            }
    203          
    204            /***************************************************************************/
    205            /* Step 0: Perform initial configuration     */
    206            /***************************************************************************/
    207            /* Configure CRC peripheral for eeprom emulation usage */
    208            ConfigureCrc();
   \                     ??EE_Init_2: (+1)
   \       0x50   0x....'....        BL       ConfigureCrc
    209          
    210            /***************************************************************************/
    211            /* Step 1: Read all lines of the flash pages of eeprom emulation to        */
    212            /*         delete corrupted lines detectable through NMI                   */
    213            /***************************************************************************/
    214            /* We set the flag indicating the cleanup phase is operating to 1 */
    215            CleanupPhase = 1;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x493F             LDR      R1,??EE_Init_0
   \       0x58   0x7008             STRB     R0,[R1, #+0]
    216            for (page = START_PAGE; page < (START_PAGE + PAGES_NUMBER); page++)
   \       0x5A   0x25FF             MOVS     R5,#+255
   \       0x5C   0x02AD             LSLS     R5,R5,#+10       ;; #+261120
   \       0x5E   0x4C3E             LDR      R4,??EE_Init_0+0x4  ;; 0x1fff75e0
   \       0x60   0x26D8             MOVS     R6,#+216
   \       0x62   0x0276             LSLS     R6,R6,#+9        ;; #+110592
   \       0x64   0x0030             MOVS     R0,R6
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x0289             LSLS     R1,R1,#+10
   \       0x6A   0x4029             ANDS     R1,R1,R5
   \       0x6C   0x....'....        BL       __aeabi_uidivmod
   \       0x70   0x0ACF             LSRS     R7,R1,#+11
   \                     ??EE_Init_4: (+1)
   \       0x72   0x0030             MOVS     R0,R6
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x0289             LSLS     R1,R1,#+10
   \       0x78   0x4029             ANDS     R1,R1,R5
   \       0x7A   0x....'....        BL       __aeabi_uidivmod
   \       0x7E   0x0AC8             LSRS     R0,R1,#+11
   \       0x80   0x300A             ADDS     R0,R0,#+10
   \       0x82   0x4287             CMP      R7,R0
   \       0x84   0xD22C             BCS      ??EE_Init_5
    217            {
    218              pageaddress = PAGE_ADDRESS(page);
   \       0x86   0x2180             MOVS     R1,#+128
   \       0x88   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x8A   0x4379             MULS     R1,R7,R1
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   \       0x8E   0x0030             MOVS     R0,R6
   \       0x90   0x6821             LDR      R1,[R4, #+0]
   \       0x92   0x0289             LSLS     R1,R1,#+10
   \       0x94   0x4029             ANDS     R1,R1,R5
   \       0x96   0x....'....        BL       __aeabi_uidiv
   \       0x9A   0x6821             LDR      R1,[R4, #+0]
   \       0x9C   0x0289             LSLS     R1,R1,#+10
   \       0x9E   0x4029             ANDS     R1,R1,R5
   \       0xA0   0x4348             MULS     R0,R1,R0
   \       0xA2   0x9900             LDR      R1,[SP, #+0]
   \       0xA4   0x1808             ADDS     R0,R1,R0
   \       0xA6   0x2180             MOVS     R1,#+128
   \       0xA8   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0xAA   0x1840             ADDS     R0,R0,R1
   \       0xAC   0x9004             STR      R0,[SP, #+16]
    219              for (varidx = 0U; varidx < PAGE_SIZE; varidx += EE_ELEMENT_SIZE)
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x9005             STR      R0,[SP, #+20]
   \                     ??EE_Init_6: (+1)
   \       0xB2   0x9805             LDR      R0,[SP, #+20]
   \       0xB4   0x2180             MOVS     R1,#+128
   \       0xB6   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xD20F             BCS      ??EE_Init_7
    220              {
    221                /* 
    222                  During the cleanup phase and only during it,
    223                  we save the address read to set its content to 0 in case it triggered an NMI (see NMI_Handler in stm32lxxx_it.c).
    224                  In the rest of the program, we do nothing in case a NMI is triggers by a reading because no NMI should be triggered
    225                  since we have cleanup the EEPROM emulated. By the way, there is still the CRC code associated to each EEPROM line
    226                  that allows to verify its valid state.
    227                */
    228                AddressRead = pageaddress + varidx;
   \       0xBC   0x9804             LDR      R0,[SP, #+16]
   \       0xBE   0x9905             LDR      R1,[SP, #+20]
   \       0xC0   0x1840             ADDS     R0,R0,R1
   \       0xC2   0x4926             LDR      R1,??EE_Init_0+0x8
   \       0xC4   0x6008             STR      R0,[R1, #+0]
    229                addressvalue = (*(__IO EE_ELEMENT_TYPE*)(pageaddress + varidx));
   \       0xC6   0x9804             LDR      R0,[SP, #+16]
   \       0xC8   0x9905             LDR      R1,[SP, #+20]
   \       0xCA   0x1840             ADDS     R0,R0,R1
   \       0xCC   0xC803             LDM      R0,{R0,R1}
   \       0xCE   0xAA0C             ADD      R2,SP,#+48
   \       0xD0   0xC203             STM      R2!,{R0,R1}
   \       0xD2   0x3A08             SUBS     R2,R2,#+8
    230              }
   \       0xD4   0x9805             LDR      R0,[SP, #+20]
   \       0xD6   0x3008             ADDS     R0,R0,#+8
   \       0xD8   0x9005             STR      R0,[SP, #+20]
   \       0xDA   0xE7EA             B        ??EE_Init_6
    231            }
   \                     ??EE_Init_7: (+1)
   \       0xDC   0x1C7F             ADDS     R7,R7,#+1
   \       0xDE   0xE7C8             B        ??EE_Init_4
    232            /* We set the flag indicating the cleanup phase is operating to 0 because it just ended */
    233            CleanupPhase = 0;
   \                     ??EE_Init_5: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x491C             LDR      R1,??EE_Init_0
   \       0xE4   0x7008             STRB     R0,[R1, #+0]
    234          
    235            /***************************************************************************/
    236            /* Step 2: Handle case of reset during transfer with no receive page       */
    237            /*         present, by setting missing receive page state                  */
    238            /***************************************************************************/
    239            /* Check if no active page and no receive page present */
    240            /* Browse all pages */
    241            for (page = START_PAGE; page < (START_PAGE + PAGES_NUMBER); page++)
   \       0xE6   0x0030             MOVS     R0,R6
   \       0xE8   0x6821             LDR      R1,[R4, #+0]
   \       0xEA   0x0289             LSLS     R1,R1,#+10
   \       0xEC   0x4029             ANDS     R1,R1,R5
   \       0xEE   0x....'....        BL       __aeabi_uidivmod
   \       0xF2   0x0AC8             LSRS     R0,R1,#+11
   \       0xF4   0x9003             STR      R0,[SP, #+12]
   \                     ??EE_Init_8: (+1)
   \       0xF6   0x9F03             LDR      R7,[SP, #+12]
   \       0xF8   0x0030             MOVS     R0,R6
   \       0xFA   0x6821             LDR      R1,[R4, #+0]
   \       0xFC   0x0289             LSLS     R1,R1,#+10
   \       0xFE   0x4029             ANDS     R1,R1,R5
   \      0x100   0x....'....        BL       __aeabi_uidivmod
   \      0x104   0x0AC8             LSRS     R0,R1,#+11
   \      0x106   0x300A             ADDS     R0,R0,#+10
   \      0x108   0x4287             CMP      R7,R0
   \      0x10A   0xD23B             BCS      ??EE_Init_9
    242            {
    243              pageaddress = PAGE_ADDRESS(page);
   \      0x10C   0x9F03             LDR      R7,[SP, #+12]
   \      0x10E   0x2080             MOVS     R0,#+128
   \      0x110   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x112   0x4347             MULS     R7,R0,R7
   \      0x114   0x0030             MOVS     R0,R6
   \      0x116   0x6821             LDR      R1,[R4, #+0]
   \      0x118   0x0289             LSLS     R1,R1,#+10
   \      0x11A   0x4029             ANDS     R1,R1,R5
   \      0x11C   0x....'....        BL       __aeabi_uidiv
   \      0x120   0x6821             LDR      R1,[R4, #+0]
   \      0x122   0x0289             LSLS     R1,R1,#+10
   \      0x124   0x4029             ANDS     R1,R1,R5
   \      0x126   0x4348             MULS     R0,R1,R0
   \      0x128   0x1838             ADDS     R0,R7,R0
   \      0x12A   0x2180             MOVS     R1,#+128
   \      0x12C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x12E   0x1840             ADDS     R0,R0,R1
   \      0x130   0x9004             STR      R0,[SP, #+16]
    244              pagestatus = GetPageState(pageaddress);
   \      0x132   0x9804             LDR      R0,[SP, #+16]
   \      0x134   0x....'....        BL       GetPageState
   \      0x138   0x4669             MOV      R1,SP
   \      0x13A   0x7208             STRB     R0,[R1, #+8]
    245          
    246              /* Search for active and receive page */
    247              if ((pagestatus == STATE_PAGE_ACTIVE) || (pagestatus == STATE_PAGE_RECEIVE))
   \      0x13C   0x4668             MOV      R0,SP
   \      0x13E   0x7A00             LDRB     R0,[R0, #+8]
   \      0x140   0x2802             CMP      R0,#+2
   \      0x142   0xD003             BEQ      ??EE_Init_10
   \      0x144   0x4668             MOV      R0,SP
   \      0x146   0x7A00             LDRB     R0,[R0, #+8]
   \      0x148   0x2801             CMP      R0,#+1
   \      0x14A   0xD109             BNE      ??EE_Init_11
    248              {
    249                nbactivereceivepage++;
   \                     ??EE_Init_10: (+1)
   \      0x14C   0x980A             LDR      R0,[SP, #+40]
   \      0x14E   0x1C40             ADDS     R0,R0,#+1
   \      0x150   0x900A             STR      R0,[SP, #+40]
   \      0x152   0xE013             B        ??EE_Init_12
   \                     ??EE_Init_0:
   \      0x154   0x....'....        DC32     CleanupPhase
   \      0x158   0x1FFF'75E0        DC32     0x1fff75e0
   \      0x15C   0x....'....        DC32     AddressRead
    250              }
    251              /* Keep index of first valid page, and last valid page */
    252              else if (pagestatus == STATE_PAGE_VALID)
   \                     ??EE_Init_11: (+1)
   \      0x160   0x4668             MOV      R0,SP
   \      0x162   0x7A00             LDRB     R0,[R0, #+8]
   \      0x164   0x2803             CMP      R0,#+3
   \      0x166   0xD109             BNE      ??EE_Init_12
    253              {
    254                if (nbvalidpage == 0U)
   \      0x168   0x9809             LDR      R0,[SP, #+36]
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD101             BNE      ??EE_Init_13
    255                {
    256                  firstvalidpage = page;
   \      0x16E   0x9803             LDR      R0,[SP, #+12]
   \      0x170   0x9006             STR      R0,[SP, #+24]
    257                }
    258                lastvalidpage = page;
   \                     ??EE_Init_13: (+1)
   \      0x172   0x9803             LDR      R0,[SP, #+12]
   \      0x174   0x9008             STR      R0,[SP, #+32]
    259                nbvalidpage++;
   \      0x176   0x9809             LDR      R0,[SP, #+36]
   \      0x178   0x1C40             ADDS     R0,R0,#+1
   \      0x17A   0x9009             STR      R0,[SP, #+36]
    260              }
    261            }
   \                     ??EE_Init_12: (+1)
   \      0x17C   0x9803             LDR      R0,[SP, #+12]
   \      0x17E   0x1C40             ADDS     R0,R0,#+1
   \      0x180   0x9003             STR      R0,[SP, #+12]
   \      0x182   0xE7B8             B        ??EE_Init_8
    262          
    263            /* Check if no active and no receive page have been detected */
    264            if (nbactivereceivepage == 0U)
   \                     ??EE_Init_9: (+1)
   \      0x184   0x980A             LDR      R0,[SP, #+40]
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xD159             BNE      ??EE_Init_14
    265            {
    266              /* Check if valid pages have been detected */
    267              if (nbvalidpage > 0U)
   \      0x18A   0x9809             LDR      R0,[SP, #+36]
   \      0x18C   0x2800             CMP      R0,#+0
   \      0x18E   0xD052             BEQ      ??EE_Init_15
    268              {
    269                /* Check state of page just before first valid page.
    270                If it is erasing page, then page after last valid page shall be set
    271                to receiving state */
    272                if (GetPageState(PAGE_ADDRESS(PREVIOUS_PAGE(firstvalidpage))) == STATE_PAGE_ERASING)
   \      0x190   0x270A             MOVS     R7,#+10
   \      0x192   0x9806             LDR      R0,[SP, #+24]
   \      0x194   0x9000             STR      R0,[SP, #+0]
   \      0x196   0x0030             MOVS     R0,R6
   \      0x198   0x6821             LDR      R1,[R4, #+0]
   \      0x19A   0x0289             LSLS     R1,R1,#+10
   \      0x19C   0x4029             ANDS     R1,R1,R5
   \      0x19E   0x....'....        BL       __aeabi_uidivmod
   \      0x1A2   0x0AC9             LSRS     R1,R1,#+11
   \      0x1A4   0x9800             LDR      R0,[SP, #+0]
   \      0x1A6   0x1A40             SUBS     R0,R0,R1
   \      0x1A8   0x3009             ADDS     R0,R0,#+9
   \      0x1AA   0x0039             MOVS     R1,R7
   \      0x1AC   0x....'....        BL       __aeabi_uidivmod
   \      0x1B0   0x9100             STR      R1,[SP, #+0]
   \      0x1B2   0x0030             MOVS     R0,R6
   \      0x1B4   0x6821             LDR      R1,[R4, #+0]
   \      0x1B6   0x0289             LSLS     R1,R1,#+10
   \      0x1B8   0x4029             ANDS     R1,R1,R5
   \      0x1BA   0x....'....        BL       __aeabi_uidivmod
   \      0x1BE   0x0AC8             LSRS     R0,R1,#+11
   \      0x1C0   0x9900             LDR      R1,[SP, #+0]
   \      0x1C2   0x1809             ADDS     R1,R1,R0
   \      0x1C4   0x2080             MOVS     R0,#+128
   \      0x1C6   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x1C8   0x4341             MULS     R1,R0,R1
   \      0x1CA   0x9100             STR      R1,[SP, #+0]
   \      0x1CC   0x0030             MOVS     R0,R6
   \      0x1CE   0x6821             LDR      R1,[R4, #+0]
   \      0x1D0   0x0289             LSLS     R1,R1,#+10
   \      0x1D2   0x4029             ANDS     R1,R1,R5
   \      0x1D4   0x....'....        BL       __aeabi_uidiv
   \      0x1D8   0x6821             LDR      R1,[R4, #+0]
   \      0x1DA   0x0289             LSLS     R1,R1,#+10
   \      0x1DC   0x4029             ANDS     R1,R1,R5
   \      0x1DE   0x4348             MULS     R0,R1,R0
   \      0x1E0   0x9900             LDR      R1,[SP, #+0]
   \      0x1E2   0x1808             ADDS     R0,R1,R0
   \      0x1E4   0x2180             MOVS     R1,#+128
   \      0x1E6   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x1E8   0x1840             ADDS     R0,R0,R1
   \      0x1EA   0x....'....        BL       GetPageState
   \      0x1EE   0x2804             CMP      R0,#+4
   \      0x1F0   0xD125             BNE      ??EE_Init_14
    273                {
    274                  if (SetPageState(FOLLOWING_PAGE(lastvalidpage), STATE_PAGE_RECEIVE) != EE_OK)
   \      0x1F2   0x2101             MOVS     R1,#+1
   \      0x1F4   0x9101             STR      R1,[SP, #+4]
   \      0x1F6   0x9808             LDR      R0,[SP, #+32]
   \      0x1F8   0x9000             STR      R0,[SP, #+0]
   \      0x1FA   0x0030             MOVS     R0,R6
   \      0x1FC   0x6821             LDR      R1,[R4, #+0]
   \      0x1FE   0x0289             LSLS     R1,R1,#+10
   \      0x200   0x4029             ANDS     R1,R1,R5
   \      0x202   0x....'....        BL       __aeabi_uidivmod
   \      0x206   0x0AC9             LSRS     R1,R1,#+11
   \      0x208   0x9800             LDR      R0,[SP, #+0]
   \      0x20A   0x1A40             SUBS     R0,R0,R1
   \      0x20C   0x1C40             ADDS     R0,R0,#+1
   \      0x20E   0x0039             MOVS     R1,R7
   \      0x210   0x....'....        BL       __aeabi_uidivmod
   \      0x214   0x000F             MOVS     R7,R1
   \      0x216   0x0030             MOVS     R0,R6
   \      0x218   0x6821             LDR      R1,[R4, #+0]
   \      0x21A   0x0289             LSLS     R1,R1,#+10
   \      0x21C   0x4029             ANDS     R1,R1,R5
   \      0x21E   0x....'....        BL       __aeabi_uidivmod
   \      0x222   0x0AC8             LSRS     R0,R1,#+11
   \      0x224   0x0039             MOVS     R1,R7
   \      0x226   0x1808             ADDS     R0,R1,R0
   \      0x228   0x9901             LDR      R1,[SP, #+4]
   \      0x22A   0x....'....        BL       SetPageState
   \      0x22E   0x2800             CMP      R0,#+0
   \      0x230   0xD005             BEQ      ??EE_Init_14
    275                  {
    276                    return EE_WRITE_ERROR;
   \      0x232   0x2002             MOVS     R0,#+2
   \      0x234   0xE2E4             B        ??EE_Init_3
    277                  }
    278                }
    279              }
    280              /* Format flash pages used for eeprom emulation in case no active, no receive, no valid pages are found */
    281              else
    282              {
    283                return EE_Format(EE_FORCED_ERASE);
   \                     ??EE_Init_15: (+1)
   \      0x236   0x2000             MOVS     R0,#+0
   \      0x238   0x....'....        BL       EE_Format
   \      0x23C   0xE2E0             B        ??EE_Init_3
    284              }
    285            }
    286          
    287            /*********************************************************************/
    288            /* Step 3: Handle case of reset during transfer, by performing       */
    289            /*         transfer recovery                                         */
    290            /*********************************************************************/
    291            /* Browse all pages */
    292            for (page = START_PAGE; page < (START_PAGE + PAGES_NUMBER); page++)
   \                     ??EE_Init_14: (+1)
   \      0x23E   0x0030             MOVS     R0,R6
   \      0x240   0x6821             LDR      R1,[R4, #+0]
   \      0x242   0x0289             LSLS     R1,R1,#+10
   \      0x244   0x4029             ANDS     R1,R1,R5
   \      0x246   0x....'....        BL       __aeabi_uidivmod
   \      0x24A   0x0ACF             LSRS     R7,R1,#+11
   \                     ??EE_Init_16: (+1)
   \      0x24C   0x0030             MOVS     R0,R6
   \      0x24E   0x6821             LDR      R1,[R4, #+0]
   \      0x250   0x0289             LSLS     R1,R1,#+10
   \      0x252   0x4029             ANDS     R1,R1,R5
   \      0x254   0x....'....        BL       __aeabi_uidivmod
   \      0x258   0x0AC8             LSRS     R0,R1,#+11
   \      0x25A   0x300A             ADDS     R0,R0,#+10
   \      0x25C   0x4287             CMP      R7,R0
   \      0x25E   0xD300             BCC      .+4
   \      0x260   0xE0B0             B        ??EE_Init_17
    293            {
    294              pageaddress = PAGE_ADDRESS(page);
   \      0x262   0x2180             MOVS     R1,#+128
   \      0x264   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x266   0x4379             MULS     R1,R7,R1
   \      0x268   0x9100             STR      R1,[SP, #+0]
   \      0x26A   0x0030             MOVS     R0,R6
   \      0x26C   0x6821             LDR      R1,[R4, #+0]
   \      0x26E   0x0289             LSLS     R1,R1,#+10
   \      0x270   0x4029             ANDS     R1,R1,R5
   \      0x272   0x....'....        BL       __aeabi_uidiv
   \      0x276   0x6821             LDR      R1,[R4, #+0]
   \      0x278   0x0289             LSLS     R1,R1,#+10
   \      0x27A   0x4029             ANDS     R1,R1,R5
   \      0x27C   0x4348             MULS     R0,R1,R0
   \      0x27E   0x9900             LDR      R1,[SP, #+0]
   \      0x280   0x1808             ADDS     R0,R1,R0
   \      0x282   0x2180             MOVS     R1,#+128
   \      0x284   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x286   0x1840             ADDS     R0,R0,R1
   \      0x288   0x9004             STR      R0,[SP, #+16]
    295              pagestatus = GetPageState(pageaddress);
   \      0x28A   0x9804             LDR      R0,[SP, #+16]
   \      0x28C   0x....'....        BL       GetPageState
   \      0x290   0x4669             MOV      R1,SP
   \      0x292   0x7208             STRB     R0,[R1, #+8]
    296          
    297              /* Check if there is receive page, meaning transfer has been interrupted */
    298              if (pagestatus == STATE_PAGE_RECEIVE)
   \      0x294   0x4668             MOV      R0,SP
   \      0x296   0x7A00             LDRB     R0,[R0, #+8]
   \      0x298   0x2801             CMP      R0,#+1
   \      0x29A   0xD000             BEQ      .+4
   \      0x29C   0xE090             B        ??EE_Init_18
    299              {
    300                /* Verify that receive page is a true one, not a corrupted page state */
    301                /* Check if page is not the first page of a bloc */
    302                if ((page != START_PAGE) && (page != (uint32_t)(START_PAGE + (PAGES_NUMBER / 2U))))
   \      0x29E   0x0030             MOVS     R0,R6
   \      0x2A0   0x6821             LDR      R1,[R4, #+0]
   \      0x2A2   0x0289             LSLS     R1,R1,#+10
   \      0x2A4   0x4029             ANDS     R1,R1,R5
   \      0x2A6   0x....'....        BL       __aeabi_uidivmod
   \      0x2AA   0x0AC8             LSRS     R0,R1,#+11
   \      0x2AC   0x4287             CMP      R7,R0
   \      0x2AE   0xD03E             BEQ      ??EE_Init_19
   \      0x2B0   0x0030             MOVS     R0,R6
   \      0x2B2   0x6821             LDR      R1,[R4, #+0]
   \      0x2B4   0x0289             LSLS     R1,R1,#+10
   \      0x2B6   0x4029             ANDS     R1,R1,R5
   \      0x2B8   0x....'....        BL       __aeabi_uidivmod
   \      0x2BC   0x0AC8             LSRS     R0,R1,#+11
   \      0x2BE   0x1D40             ADDS     R0,R0,#+5
   \      0x2C0   0x4287             CMP      R7,R0
   \      0x2C2   0xD034             BEQ      ??EE_Init_19
    303                {
    304                  /* Check that previous page is valid state */
    305                  if (GetPageState(PAGE_ADDRESS(PREVIOUS_PAGE(page))) == STATE_PAGE_VALID)
   \      0x2C4   0x0030             MOVS     R0,R6
   \      0x2C6   0x6821             LDR      R1,[R4, #+0]
   \      0x2C8   0x0289             LSLS     R1,R1,#+10
   \      0x2CA   0x4029             ANDS     R1,R1,R5
   \      0x2CC   0x....'....        BL       __aeabi_uidivmod
   \      0x2D0   0x0AC8             LSRS     R0,R1,#+11
   \      0x2D2   0x1A38             SUBS     R0,R7,R0
   \      0x2D4   0x3009             ADDS     R0,R0,#+9
   \      0x2D6   0x210A             MOVS     R1,#+10
   \      0x2D8   0x....'....        BL       __aeabi_uidivmod
   \      0x2DC   0x9100             STR      R1,[SP, #+0]
   \      0x2DE   0x0030             MOVS     R0,R6
   \      0x2E0   0x6821             LDR      R1,[R4, #+0]
   \      0x2E2   0x0289             LSLS     R1,R1,#+10
   \      0x2E4   0x4029             ANDS     R1,R1,R5
   \      0x2E6   0x....'....        BL       __aeabi_uidivmod
   \      0x2EA   0x0AC8             LSRS     R0,R1,#+11
   \      0x2EC   0x9900             LDR      R1,[SP, #+0]
   \      0x2EE   0x1809             ADDS     R1,R1,R0
   \      0x2F0   0x2080             MOVS     R0,#+128
   \      0x2F2   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x2F4   0x4341             MULS     R1,R0,R1
   \      0x2F6   0x9100             STR      R1,[SP, #+0]
   \      0x2F8   0x0030             MOVS     R0,R6
   \      0x2FA   0x6821             LDR      R1,[R4, #+0]
   \      0x2FC   0x0289             LSLS     R1,R1,#+10
   \      0x2FE   0x4029             ANDS     R1,R1,R5
   \      0x300   0x....'....        BL       __aeabi_uidiv
   \      0x304   0x6821             LDR      R1,[R4, #+0]
   \      0x306   0x0289             LSLS     R1,R1,#+10
   \      0x308   0x4029             ANDS     R1,R1,R5
   \      0x30A   0x4348             MULS     R0,R1,R0
   \      0x30C   0x9900             LDR      R1,[SP, #+0]
   \      0x30E   0x1808             ADDS     R0,R1,R0
   \      0x310   0x2180             MOVS     R1,#+128
   \      0x312   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x314   0x1840             ADDS     R0,R0,R1
   \      0x316   0x....'....        BL       GetPageState
   \      0x31A   0x2803             CMP      R0,#+3
   \      0x31C   0xD103             BNE      ??EE_Init_20
    306                  {
    307                    /* The receive page is a true receive page */
    308                    pagestate = STATE_RELIABLE;
   \      0x31E   0x2000             MOVS     R0,#+0
   \      0x320   0x4669             MOV      R1,SP
   \      0x322   0x7248             STRB     R0,[R1, #+9]
   \      0x324   0xE037             B        ??EE_Init_21
    309                  }
    310                  else /* Previous page is not valid state */
    311                  {
    312                    /* The receive page is false receive page due to header corruption */
    313                    pagestate = STATE_CORRUPTED;
   \                     ??EE_Init_20: (+1)
   \      0x326   0x2001             MOVS     R0,#+1
   \      0x328   0x4669             MOV      R1,SP
   \      0x32A   0x7248             STRB     R0,[R1, #+9]
   \      0x32C   0xE033             B        ??EE_Init_21
    314                  }
    315                }
    316                else /* The receive page is the first page of a bloc */
    317                {
    318                  /* Check that following page is erased state */
    319                  if (GetPageState(PAGE_ADDRESS(FOLLOWING_PAGE(page))) == STATE_PAGE_ERASED)
   \                     ??EE_Init_19: (+1)
   \      0x32E   0x0030             MOVS     R0,R6
   \      0x330   0x6821             LDR      R1,[R4, #+0]
   \      0x332   0x0289             LSLS     R1,R1,#+10
   \      0x334   0x4029             ANDS     R1,R1,R5
   \      0x336   0x....'....        BL       __aeabi_uidivmod
   \      0x33A   0x0AC8             LSRS     R0,R1,#+11
   \      0x33C   0x1A38             SUBS     R0,R7,R0
   \      0x33E   0x1C40             ADDS     R0,R0,#+1
   \      0x340   0x210A             MOVS     R1,#+10
   \      0x342   0x....'....        BL       __aeabi_uidivmod
   \      0x346   0x9100             STR      R1,[SP, #+0]
   \      0x348   0x0030             MOVS     R0,R6
   \      0x34A   0x6821             LDR      R1,[R4, #+0]
   \      0x34C   0x0289             LSLS     R1,R1,#+10
   \      0x34E   0x4029             ANDS     R1,R1,R5
   \      0x350   0x....'....        BL       __aeabi_uidivmod
   \      0x354   0x0AC8             LSRS     R0,R1,#+11
   \      0x356   0x9900             LDR      R1,[SP, #+0]
   \      0x358   0x1809             ADDS     R1,R1,R0
   \      0x35A   0x2080             MOVS     R0,#+128
   \      0x35C   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x35E   0x4341             MULS     R1,R0,R1
   \      0x360   0x9100             STR      R1,[SP, #+0]
   \      0x362   0x0030             MOVS     R0,R6
   \      0x364   0x6821             LDR      R1,[R4, #+0]
   \      0x366   0x0289             LSLS     R1,R1,#+10
   \      0x368   0x4029             ANDS     R1,R1,R5
   \      0x36A   0x....'....        BL       __aeabi_uidiv
   \      0x36E   0x6821             LDR      R1,[R4, #+0]
   \      0x370   0x0289             LSLS     R1,R1,#+10
   \      0x372   0x4029             ANDS     R1,R1,R5
   \      0x374   0x4348             MULS     R0,R1,R0
   \      0x376   0x9900             LDR      R1,[SP, #+0]
   \      0x378   0x1808             ADDS     R0,R1,R0
   \      0x37A   0x2180             MOVS     R1,#+128
   \      0x37C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x37E   0x1840             ADDS     R0,R0,R1
   \      0x380   0x....'....        BL       GetPageState
   \      0x384   0x2800             CMP      R0,#+0
   \      0x386   0xD103             BNE      ??EE_Init_22
    320                  {
    321                    /* The receive page is a true receive page */
    322                    pagestate = STATE_RELIABLE;
   \      0x388   0x2000             MOVS     R0,#+0
   \      0x38A   0x4669             MOV      R1,SP
   \      0x38C   0x7248             STRB     R0,[R1, #+9]
   \      0x38E   0xE002             B        ??EE_Init_21
    323                  }
    324                  else /* Following page is not erased state */
    325                  {
    326                    /* The receive page is false receive page due to header corruption */
    327                    pagestate = STATE_CORRUPTED;
   \                     ??EE_Init_22: (+1)
   \      0x390   0x2001             MOVS     R0,#+1
   \      0x392   0x4669             MOV      R1,SP
   \      0x394   0x7248             STRB     R0,[R1, #+9]
    328                  }
    329                }
    330          
    331                /* If the receive page is a true receive page, resume pages transfer */
    332                if (pagestate == STATE_RELIABLE)
   \                     ??EE_Init_21: (+1)
   \      0x396   0x4668             MOV      R0,SP
   \      0x398   0x7A40             LDRB     R0,[R0, #+9]
   \      0x39A   0x2800             CMP      R0,#+0
   \      0x39C   0xD110             BNE      ??EE_Init_18
    333                {
    334                  /* Initialize current active page */
    335                  ubCurrentActivePage = page;
   \      0x39E   0x0038             MOVS     R0,R7
   \      0x3A0   0x49A2             LDR      R1,??EE_Init_1
   \      0x3A2   0x7008             STRB     R0,[R1, #+0]
    336          
    337                  /* Resume the interrupted page transfer, using dummy new data */
    338                  if (PagesTransfer(0U, 0U, EE_TRANSFER_RECOVER) != EE_CLEANUP_REQUIRED)
   \      0x3A4   0x2201             MOVS     R2,#+1
   \      0x3A6   0x2100             MOVS     R1,#+0
   \      0x3A8   0x2000             MOVS     R0,#+0
   \      0x3AA   0x....'....        BL       PagesTransfer
   \      0x3AE   0x2180             MOVS     R1,#+128
   \      0x3B0   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \      0x3B2   0x4288             CMP      R0,R1
   \      0x3B4   0xD001             BEQ      ??EE_Init_23
    339                  {
    340                    return EE_TRANSFER_ERROR;
   \      0x3B6   0x200C             MOVS     R0,#+12
   \      0x3B8   0xE222             B        ??EE_Init_3
    341                  }
    342          
    343                  /* Memorize transfer recovery occured */
    344                  recoverytransfer = 1U;
   \                     ??EE_Init_23: (+1)
   \      0x3BA   0x2001             MOVS     R0,#+1
   \      0x3BC   0x900B             STR      R0,[SP, #+44]
    345          
    346                  /* transfer recovery is done, then stop searching receive page */
    347                  break;
   \      0x3BE   0xE001             B        ??EE_Init_17
    348                }
    349              }
    350            }
   \                     ??EE_Init_18: (+1)
   \      0x3C0   0x1C7F             ADDS     R7,R7,#+1
   \      0x3C2   0xE743             B        ??EE_Init_16
    351          
    352            /*********************************************************************/
    353            /* Step 4: Verify presence of one unique active page                 */
    354            /*         If more than one active page, raise error                 */
    355            /*         If no active page present, set missing active page        */
    356            /*********************************************************************/
    357            /* Browse all pages to search for active pages */
    358            nbactivepage = 0U;
   \                     ??EE_Init_17: (+1)
   \      0x3C4   0x2000             MOVS     R0,#+0
   \      0x3C6   0x9007             STR      R0,[SP, #+28]
    359            for (page = START_PAGE; page < (START_PAGE + PAGES_NUMBER); page++)
   \      0x3C8   0x0030             MOVS     R0,R6
   \      0x3CA   0x6821             LDR      R1,[R4, #+0]
   \      0x3CC   0x0289             LSLS     R1,R1,#+10
   \      0x3CE   0x4029             ANDS     R1,R1,R5
   \      0x3D0   0x....'....        BL       __aeabi_uidivmod
   \      0x3D4   0x0AC8             LSRS     R0,R1,#+11
   \      0x3D6   0x9003             STR      R0,[SP, #+12]
   \                     ??EE_Init_24: (+1)
   \      0x3D8   0x9F03             LDR      R7,[SP, #+12]
   \      0x3DA   0x0030             MOVS     R0,R6
   \      0x3DC   0x6821             LDR      R1,[R4, #+0]
   \      0x3DE   0x0289             LSLS     R1,R1,#+10
   \      0x3E0   0x4029             ANDS     R1,R1,R5
   \      0x3E2   0x....'....        BL       __aeabi_uidivmod
   \      0x3E6   0x0AC8             LSRS     R0,R1,#+11
   \      0x3E8   0x300A             ADDS     R0,R0,#+10
   \      0x3EA   0x4287             CMP      R7,R0
   \      0x3EC   0xD300             BCC      .+4
   \      0x3EE   0xE0BC             B        ??EE_Init_25
    360            {
    361              pageaddress = PAGE_ADDRESS(page);
   \      0x3F0   0x2780             MOVS     R7,#+128
   \      0x3F2   0x053F             LSLS     R7,R7,#+20       ;; #+134217728
   \      0x3F4   0x9903             LDR      R1,[SP, #+12]
   \      0x3F6   0x2080             MOVS     R0,#+128
   \      0x3F8   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x3FA   0x4341             MULS     R1,R0,R1
   \      0x3FC   0x9100             STR      R1,[SP, #+0]
   \      0x3FE   0x0030             MOVS     R0,R6
   \      0x400   0x6821             LDR      R1,[R4, #+0]
   \      0x402   0x0289             LSLS     R1,R1,#+10
   \      0x404   0x4029             ANDS     R1,R1,R5
   \      0x406   0x....'....        BL       __aeabi_uidiv
   \      0x40A   0x6821             LDR      R1,[R4, #+0]
   \      0x40C   0x0289             LSLS     R1,R1,#+10
   \      0x40E   0x4029             ANDS     R1,R1,R5
   \      0x410   0x4348             MULS     R0,R1,R0
   \      0x412   0x9900             LDR      R1,[SP, #+0]
   \      0x414   0x1808             ADDS     R0,R1,R0
   \      0x416   0x19C0             ADDS     R0,R0,R7
   \      0x418   0x9004             STR      R0,[SP, #+16]
    362              pagestatus = GetPageState(pageaddress);
   \      0x41A   0x9804             LDR      R0,[SP, #+16]
   \      0x41C   0x....'....        BL       GetPageState
   \      0x420   0x4669             MOV      R1,SP
   \      0x422   0x7208             STRB     R0,[R1, #+8]
    363          
    364              /* Search for active page */
    365              if (pagestatus == STATE_PAGE_ACTIVE)
   \      0x424   0x4668             MOV      R0,SP
   \      0x426   0x7A00             LDRB     R0,[R0, #+8]
   \      0x428   0x2802             CMP      R0,#+2
   \      0x42A   0xD000             BEQ      .+4
   \      0x42C   0xE093             B        ??EE_Init_26
    366              {
    367                /* Verify that active page is a true one, not a corrupted page state */
    368                /* Check if page is not the first page of a bloc */
    369                if ((page != START_PAGE) && (page != (uint32_t)(START_PAGE + (PAGES_NUMBER / 2U))))
   \      0x42E   0x9803             LDR      R0,[SP, #+12]
   \      0x430   0x9000             STR      R0,[SP, #+0]
   \      0x432   0x0030             MOVS     R0,R6
   \      0x434   0x6821             LDR      R1,[R4, #+0]
   \      0x436   0x0289             LSLS     R1,R1,#+10
   \      0x438   0x4029             ANDS     R1,R1,R5
   \      0x43A   0x....'....        BL       __aeabi_uidivmod
   \      0x43E   0x0AC9             LSRS     R1,R1,#+11
   \      0x440   0x9800             LDR      R0,[SP, #+0]
   \      0x442   0x4288             CMP      R0,R1
   \      0x444   0xD042             BEQ      ??EE_Init_27
   \      0x446   0x9803             LDR      R0,[SP, #+12]
   \      0x448   0x9000             STR      R0,[SP, #+0]
   \      0x44A   0x0030             MOVS     R0,R6
   \      0x44C   0x6821             LDR      R1,[R4, #+0]
   \      0x44E   0x0289             LSLS     R1,R1,#+10
   \      0x450   0x4029             ANDS     R1,R1,R5
   \      0x452   0x....'....        BL       __aeabi_uidivmod
   \      0x456   0x0AC9             LSRS     R1,R1,#+11
   \      0x458   0x1D49             ADDS     R1,R1,#+5
   \      0x45A   0x9800             LDR      R0,[SP, #+0]
   \      0x45C   0x4288             CMP      R0,R1
   \      0x45E   0xD035             BEQ      ??EE_Init_27
    370                {
    371                  /* Check that previous page is valid state */
    372                  if (GetPageState(PAGE_ADDRESS(PREVIOUS_PAGE(page))) == STATE_PAGE_VALID)
   \      0x460   0x9803             LDR      R0,[SP, #+12]
   \      0x462   0x9000             STR      R0,[SP, #+0]
   \      0x464   0x0030             MOVS     R0,R6
   \      0x466   0x6821             LDR      R1,[R4, #+0]
   \      0x468   0x0289             LSLS     R1,R1,#+10
   \      0x46A   0x4029             ANDS     R1,R1,R5
   \      0x46C   0x....'....        BL       __aeabi_uidivmod
   \      0x470   0x0AC9             LSRS     R1,R1,#+11
   \      0x472   0x9800             LDR      R0,[SP, #+0]
   \      0x474   0x1A40             SUBS     R0,R0,R1
   \      0x476   0x3009             ADDS     R0,R0,#+9
   \      0x478   0x210A             MOVS     R1,#+10
   \      0x47A   0x....'....        BL       __aeabi_uidivmod
   \      0x47E   0x9100             STR      R1,[SP, #+0]
   \      0x480   0x0030             MOVS     R0,R6
   \      0x482   0x6821             LDR      R1,[R4, #+0]
   \      0x484   0x0289             LSLS     R1,R1,#+10
   \      0x486   0x4029             ANDS     R1,R1,R5
   \      0x488   0x....'....        BL       __aeabi_uidivmod
   \      0x48C   0x0AC8             LSRS     R0,R1,#+11
   \      0x48E   0x9900             LDR      R1,[SP, #+0]
   \      0x490   0x1809             ADDS     R1,R1,R0
   \      0x492   0x2080             MOVS     R0,#+128
   \      0x494   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x496   0x4341             MULS     R1,R0,R1
   \      0x498   0x9100             STR      R1,[SP, #+0]
   \      0x49A   0x0030             MOVS     R0,R6
   \      0x49C   0x6821             LDR      R1,[R4, #+0]
   \      0x49E   0x0289             LSLS     R1,R1,#+10
   \      0x4A0   0x4029             ANDS     R1,R1,R5
   \      0x4A2   0x....'....        BL       __aeabi_uidiv
   \      0x4A6   0x6821             LDR      R1,[R4, #+0]
   \      0x4A8   0x0289             LSLS     R1,R1,#+10
   \      0x4AA   0x4029             ANDS     R1,R1,R5
   \      0x4AC   0x4348             MULS     R0,R1,R0
   \      0x4AE   0x9900             LDR      R1,[SP, #+0]
   \      0x4B0   0x1808             ADDS     R0,R1,R0
   \      0x4B2   0x19C0             ADDS     R0,R0,R7
   \      0x4B4   0x....'....        BL       GetPageState
   \      0x4B8   0x2803             CMP      R0,#+3
   \      0x4BA   0xD103             BNE      ??EE_Init_28
    373                  {
    374                    /* The active page is a true active page */
    375                    pagestate = STATE_RELIABLE;
   \      0x4BC   0x2000             MOVS     R0,#+0
   \      0x4BE   0x4669             MOV      R1,SP
   \      0x4C0   0x7248             STRB     R0,[R1, #+9]
   \      0x4C2   0xE038             B        ??EE_Init_29
    376                  }
    377                  else /* Previous page is not valid state */
    378                  {
    379                    /* The active page is false active page due to header corruption */
    380                    pagestate = STATE_CORRUPTED;
   \                     ??EE_Init_28: (+1)
   \      0x4C4   0x2001             MOVS     R0,#+1
   \      0x4C6   0x4669             MOV      R1,SP
   \      0x4C8   0x7248             STRB     R0,[R1, #+9]
   \      0x4CA   0xE034             B        ??EE_Init_29
    381                  }
    382                }
    383                else /* The active page is the first page of a bloc */
    384                {
    385                  /* Check that following page is erased state */
    386                  if (GetPageState(PAGE_ADDRESS(FOLLOWING_PAGE(page))) == STATE_PAGE_ERASED)
   \                     ??EE_Init_27: (+1)
   \      0x4CC   0x9803             LDR      R0,[SP, #+12]
   \      0x4CE   0x9000             STR      R0,[SP, #+0]
   \      0x4D0   0x0030             MOVS     R0,R6
   \      0x4D2   0x6821             LDR      R1,[R4, #+0]
   \      0x4D4   0x0289             LSLS     R1,R1,#+10
   \      0x4D6   0x4029             ANDS     R1,R1,R5
   \      0x4D8   0x....'....        BL       __aeabi_uidivmod
   \      0x4DC   0x0AC9             LSRS     R1,R1,#+11
   \      0x4DE   0x9800             LDR      R0,[SP, #+0]
   \      0x4E0   0x1A40             SUBS     R0,R0,R1
   \      0x4E2   0x1C40             ADDS     R0,R0,#+1
   \      0x4E4   0x210A             MOVS     R1,#+10
   \      0x4E6   0x....'....        BL       __aeabi_uidivmod
   \      0x4EA   0x9100             STR      R1,[SP, #+0]
   \      0x4EC   0x0030             MOVS     R0,R6
   \      0x4EE   0x6821             LDR      R1,[R4, #+0]
   \      0x4F0   0x0289             LSLS     R1,R1,#+10
   \      0x4F2   0x4029             ANDS     R1,R1,R5
   \      0x4F4   0x....'....        BL       __aeabi_uidivmod
   \      0x4F8   0x0AC8             LSRS     R0,R1,#+11
   \      0x4FA   0x9900             LDR      R1,[SP, #+0]
   \      0x4FC   0x1809             ADDS     R1,R1,R0
   \      0x4FE   0x2080             MOVS     R0,#+128
   \      0x500   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x502   0x4341             MULS     R1,R0,R1
   \      0x504   0x9100             STR      R1,[SP, #+0]
   \      0x506   0x0030             MOVS     R0,R6
   \      0x508   0x6821             LDR      R1,[R4, #+0]
   \      0x50A   0x0289             LSLS     R1,R1,#+10
   \      0x50C   0x4029             ANDS     R1,R1,R5
   \      0x50E   0x....'....        BL       __aeabi_uidiv
   \      0x512   0x6821             LDR      R1,[R4, #+0]
   \      0x514   0x0289             LSLS     R1,R1,#+10
   \      0x516   0x4029             ANDS     R1,R1,R5
   \      0x518   0x4348             MULS     R0,R1,R0
   \      0x51A   0x9900             LDR      R1,[SP, #+0]
   \      0x51C   0x1808             ADDS     R0,R1,R0
   \      0x51E   0x19C0             ADDS     R0,R0,R7
   \      0x520   0x....'....        BL       GetPageState
   \      0x524   0x2800             CMP      R0,#+0
   \      0x526   0xD103             BNE      ??EE_Init_30
    387                  {
    388                    /* The active page is a true active page */
    389                    pagestate = STATE_RELIABLE;
   \      0x528   0x2000             MOVS     R0,#+0
   \      0x52A   0x4669             MOV      R1,SP
   \      0x52C   0x7248             STRB     R0,[R1, #+9]
   \      0x52E   0xE002             B        ??EE_Init_29
    390                  }
    391                  else /* Following page is not erased state */
    392                  {
    393                    /* The active page is false active page due to header corruption */
    394                    pagestate = STATE_CORRUPTED;
   \                     ??EE_Init_30: (+1)
   \      0x530   0x2001             MOVS     R0,#+1
   \      0x532   0x4669             MOV      R1,SP
   \      0x534   0x7248             STRB     R0,[R1, #+9]
    395                  }
    396                }
    397          
    398                /* If the active page is a true active page, initialize global variables */
    399                if (pagestate == STATE_RELIABLE)
   \                     ??EE_Init_29: (+1)
   \      0x536   0x4668             MOV      R0,SP
   \      0x538   0x7A40             LDRB     R0,[R0, #+9]
   \      0x53A   0x2800             CMP      R0,#+0
   \      0x53C   0xD111             BNE      ??EE_Init_31
    400                {
    401                  if (nbactivepage == 0U)
   \      0x53E   0x9807             LDR      R0,[SP, #+28]
   \      0x540   0x2800             CMP      R0,#+0
   \      0x542   0xD106             BNE      ??EE_Init_32
    402                  {
    403                    ubCurrentActivePage = page;
   \      0x544   0x9803             LDR      R0,[SP, #+12]
   \      0x546   0x4939             LDR      R1,??EE_Init_1
   \      0x548   0x7008             STRB     R0,[R1, #+0]
    404                    nbactivepage++;
   \      0x54A   0x9807             LDR      R0,[SP, #+28]
   \      0x54C   0x1C40             ADDS     R0,R0,#+1
   \      0x54E   0x9007             STR      R0,[SP, #+28]
   \      0x550   0xE007             B        ??EE_Init_31
    405                  }
    406                  else
    407                  {
    408                    /* Error: More than one reliable active page is present */
    409                    return EE_INVALID_PAGE_SEQUENCE;
   \                     ??EE_Init_32: (+1)
   \      0x552   0x200A             MOVS     R0,#+10
   \      0x554   0xE154             B        ??EE_Init_3
    410                  }
    411                }
    412              }
    413              /* Keep index of last valid page, will be required in case no active page is found */
    414              else if (pagestatus == STATE_PAGE_VALID)
   \                     ??EE_Init_26: (+1)
   \      0x556   0x4668             MOV      R0,SP
   \      0x558   0x7A00             LDRB     R0,[R0, #+8]
   \      0x55A   0x2803             CMP      R0,#+3
   \      0x55C   0xD101             BNE      ??EE_Init_31
    415              {
    416                lastvalidpage = page;
   \      0x55E   0x9803             LDR      R0,[SP, #+12]
   \      0x560   0x9008             STR      R0,[SP, #+32]
    417              }
    418            }
   \                     ??EE_Init_31: (+1)
   \      0x562   0x9803             LDR      R0,[SP, #+12]
   \      0x564   0x1C40             ADDS     R0,R0,#+1
   \      0x566   0x9003             STR      R0,[SP, #+12]
   \      0x568   0xE736             B        ??EE_Init_24
    419          
    420            /* In case no active page is found, set page after last valid page to active state */
    421            if (nbactivepage == 0U)
   \                     ??EE_Init_25: (+1)
   \      0x56A   0x9807             LDR      R0,[SP, #+28]
   \      0x56C   0x2800             CMP      R0,#+0
   \      0x56E   0xD122             BNE      ??EE_Init_33
    422            {
    423              ubCurrentActivePage = FOLLOWING_PAGE(lastvalidpage);
   \      0x570   0x4F2E             LDR      R7,??EE_Init_1
   \      0x572   0x9808             LDR      R0,[SP, #+32]
   \      0x574   0x9000             STR      R0,[SP, #+0]
   \      0x576   0x0030             MOVS     R0,R6
   \      0x578   0x6821             LDR      R1,[R4, #+0]
   \      0x57A   0x0289             LSLS     R1,R1,#+10
   \      0x57C   0x4029             ANDS     R1,R1,R5
   \      0x57E   0x....'....        BL       __aeabi_uidivmod
   \      0x582   0x0AC9             LSRS     R1,R1,#+11
   \      0x584   0x9800             LDR      R0,[SP, #+0]
   \      0x586   0x1A40             SUBS     R0,R0,R1
   \      0x588   0x1C40             ADDS     R0,R0,#+1
   \      0x58A   0x210A             MOVS     R1,#+10
   \      0x58C   0x....'....        BL       __aeabi_uidivmod
   \      0x590   0x9100             STR      R1,[SP, #+0]
   \      0x592   0x0030             MOVS     R0,R6
   \      0x594   0x6821             LDR      R1,[R4, #+0]
   \      0x596   0x0289             LSLS     R1,R1,#+10
   \      0x598   0x4029             ANDS     R1,R1,R5
   \      0x59A   0x....'....        BL       __aeabi_uidivmod
   \      0x59E   0x0AC8             LSRS     R0,R1,#+11
   \      0x5A0   0x9900             LDR      R1,[SP, #+0]
   \      0x5A2   0x1808             ADDS     R0,R1,R0
   \      0x5A4   0x7038             STRB     R0,[R7, #+0]
    424              if (SetPageState(ubCurrentActivePage, STATE_PAGE_ACTIVE) != EE_OK)
   \      0x5A6   0x2102             MOVS     R1,#+2
   \      0x5A8   0x7838             LDRB     R0,[R7, #+0]
   \      0x5AA   0x....'....        BL       SetPageState
   \      0x5AE   0x2800             CMP      R0,#+0
   \      0x5B0   0xD001             BEQ      ??EE_Init_33
    425              {
    426                return EE_WRITE_ERROR;
   \      0x5B2   0x2002             MOVS     R0,#+2
   \      0x5B4   0xE124             B        ??EE_Init_3
    427              }
    428            }
    429          
    430            /*********************************************************************/
    431            /* Step 5: Initialize eeprom emulation global variables relative     */
    432            /*         to active page                                            */
    433            /*********************************************************************/
    434            /* Initialize global variables, with elements detected in active page */
    435            uhNbWrittenElements = 0U;
   \                     ??EE_Init_33: (+1)
   \      0x5B6   0x....             LDR      R7,??DataTable3
   \      0x5B8   0x2000             MOVS     R0,#+0
   \      0x5BA   0x8038             STRH     R0,[R7, #+0]
    436            uwAddressNextWrite = PAGE_HEADER_SIZE;
   \      0x5BC   0x2020             MOVS     R0,#+32
   \      0x5BE   0x....             LDR      R1,??DataTable3_1
   \      0x5C0   0x6008             STR      R0,[R1, #+0]
    437          
    438            for (varidx = PAGE_HEADER_SIZE; varidx < PAGE_SIZE; varidx += EE_ELEMENT_SIZE)
   \      0x5C2   0x9005             STR      R0,[SP, #+20]
   \                     ??EE_Init_34: (+1)
   \      0x5C4   0x9805             LDR      R0,[SP, #+20]
   \      0x5C6   0x2180             MOVS     R1,#+128
   \      0x5C8   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x5CA   0x4288             CMP      R0,R1
   \      0x5CC   0xD230             BCS      ??EE_Init_35
    439            {
    440              /* Check elements present in active page */
    441              addressvalue = (*(__IO EE_ELEMENT_TYPE*)(PAGE_ADDRESS(ubCurrentActivePage) + varidx));
   \      0x5CE   0x4817             LDR      R0,??EE_Init_1
   \      0x5D0   0x7801             LDRB     R1,[R0, #+0]
   \      0x5D2   0x2080             MOVS     R0,#+128
   \      0x5D4   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x5D6   0x4341             MULS     R1,R0,R1
   \      0x5D8   0x9100             STR      R1,[SP, #+0]
   \      0x5DA   0x0030             MOVS     R0,R6
   \      0x5DC   0x6821             LDR      R1,[R4, #+0]
   \      0x5DE   0x0289             LSLS     R1,R1,#+10
   \      0x5E0   0x4029             ANDS     R1,R1,R5
   \      0x5E2   0x....'....        BL       __aeabi_uidiv
   \      0x5E6   0x6821             LDR      R1,[R4, #+0]
   \      0x5E8   0x0289             LSLS     R1,R1,#+10
   \      0x5EA   0x4029             ANDS     R1,R1,R5
   \      0x5EC   0x4348             MULS     R0,R1,R0
   \      0x5EE   0x9900             LDR      R1,[SP, #+0]
   \      0x5F0   0x1808             ADDS     R0,R1,R0
   \      0x5F2   0x9905             LDR      R1,[SP, #+20]
   \      0x5F4   0x1840             ADDS     R0,R0,R1
   \      0x5F6   0x2180             MOVS     R1,#+128
   \      0x5F8   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x5FA   0x1840             ADDS     R0,R0,R1
   \      0x5FC   0xC803             LDM      R0,{R0,R1}
   \      0x5FE   0xAA0C             ADD      R2,SP,#+48
   \      0x600   0xC203             STM      R2!,{R0,R1}
   \      0x602   0x3A08             SUBS     R2,R2,#+8
    442              if (addressvalue != EE_MASK_FULL)
   \      0x604   0xA80C             ADD      R0,SP,#+48
   \      0x606   0xC803             LDM      R0,{R0,R1}
   \      0x608   0x....             ADR      R2,??DataTable4
   \      0x60A   0xCA0C             LDM      R2,{R2,R3}
   \      0x60C   0x4299             CMP      R1,R3
   \      0x60E   0xD101             BNE      ??EE_Init_36
   \      0x610   0x4290             CMP      R0,R2
   \      0x612   0xD00D             BEQ      ??EE_Init_37
    443              {
    444                /* Then increment uhNbWrittenElements and uwAddressNextWrite */
    445                uhNbWrittenElements++;
   \                     ??EE_Init_36: (+1)
   \      0x614   0x8838             LDRH     R0,[R7, #+0]
   \      0x616   0x1C40             ADDS     R0,R0,#+1
   \      0x618   0x8038             STRH     R0,[R7, #+0]
    446                uwAddressNextWrite += EE_ELEMENT_SIZE;
   \      0x61A   0x....             LDR      R0,??DataTable3_1
   \      0x61C   0x6801             LDR      R1,[R0, #+0]
   \      0x61E   0x3108             ADDS     R1,R1,#+8
   \      0x620   0x6001             STR      R1,[R0, #+0]
    447              }
   \      0x622   0x9805             LDR      R0,[SP, #+20]
   \      0x624   0x3008             ADDS     R0,R0,#+8
   \      0x626   0x9005             STR      R0,[SP, #+20]
   \      0x628   0xE7CC             B        ??EE_Init_34
   \      0x62A   0xBF00             Nop
   \                     ??EE_Init_1:
   \      0x62C   0x....'....        DC32     ubCurrentActivePage
    448              else /* no more element in the page */
    449              {
    450                break;
    451              }
    452            }
    453          
    454            /*********************************************************************/
    455            /* Step 6: Finalize eeprom emulation global variables relative       */
    456            /*         to valid pages, and check consistency of pages sequence   */
    457            /*********************************************************************/
    458            /* Check consistency of pages sequence: one active page, optionnally some valid pages before */
    459            /* Update global variable uhNbWrittenElements if valid pages are found */
    460            page = ubCurrentActivePage;
   \                     ??EE_Init_37: (+1)
   \                     ??EE_Init_35: (+1)
   \      0x630   0x....             LDR      R0,??DataTable5
   \      0x632   0x7800             LDRB     R0,[R0, #+0]
   \      0x634   0x9003             STR      R0,[SP, #+12]
    461            firstvalidpage = ubCurrentActivePage;
   \      0x636   0x....             LDR      R0,??DataTable5
   \      0x638   0x7800             LDRB     R0,[R0, #+0]
   \      0x63A   0x9006             STR      R0,[SP, #+24]
    462            while ((page != START_PAGE) && (page != (uint32_t)(START_PAGE + (PAGES_NUMBER / 2U))))
   \                     ??EE_Init_38: (+1)
   \      0x63C   0x9803             LDR      R0,[SP, #+12]
   \      0x63E   0x9000             STR      R0,[SP, #+0]
   \      0x640   0x0030             MOVS     R0,R6
   \      0x642   0x6821             LDR      R1,[R4, #+0]
   \      0x644   0x0289             LSLS     R1,R1,#+10
   \      0x646   0x4029             ANDS     R1,R1,R5
   \      0x648   0x....'....        BL       __aeabi_uidivmod
   \      0x64C   0x0AC9             LSRS     R1,R1,#+11
   \      0x64E   0x9800             LDR      R0,[SP, #+0]
   \      0x650   0x4288             CMP      R0,R1
   \      0x652   0xD04A             BEQ      ??EE_Init_39
   \      0x654   0x9803             LDR      R0,[SP, #+12]
   \      0x656   0x9000             STR      R0,[SP, #+0]
   \      0x658   0x0030             MOVS     R0,R6
   \      0x65A   0x6821             LDR      R1,[R4, #+0]
   \      0x65C   0x0289             LSLS     R1,R1,#+10
   \      0x65E   0x4029             ANDS     R1,R1,R5
   \      0x660   0x....'....        BL       __aeabi_uidivmod
   \      0x664   0x0AC9             LSRS     R1,R1,#+11
   \      0x666   0x1D49             ADDS     R1,R1,#+5
   \      0x668   0x9800             LDR      R0,[SP, #+0]
   \      0x66A   0x4288             CMP      R0,R1
   \      0x66C   0xD03D             BEQ      ??EE_Init_39
    463            {
    464              /* Decrement page index among circular pages list */
    465              page = PREVIOUS_PAGE(page);
   \      0x66E   0x9803             LDR      R0,[SP, #+12]
   \      0x670   0x9000             STR      R0,[SP, #+0]
   \      0x672   0x0030             MOVS     R0,R6
   \      0x674   0x6821             LDR      R1,[R4, #+0]
   \      0x676   0x0289             LSLS     R1,R1,#+10
   \      0x678   0x4029             ANDS     R1,R1,R5
   \      0x67A   0x....'....        BL       __aeabi_uidivmod
   \      0x67E   0x0AC9             LSRS     R1,R1,#+11
   \      0x680   0x9800             LDR      R0,[SP, #+0]
   \      0x682   0x1A40             SUBS     R0,R0,R1
   \      0x684   0x3009             ADDS     R0,R0,#+9
   \      0x686   0x210A             MOVS     R1,#+10
   \      0x688   0x....'....        BL       __aeabi_uidivmod
   \      0x68C   0x9100             STR      R1,[SP, #+0]
   \      0x68E   0x0030             MOVS     R0,R6
   \      0x690   0x6821             LDR      R1,[R4, #+0]
   \      0x692   0x0289             LSLS     R1,R1,#+10
   \      0x694   0x4029             ANDS     R1,R1,R5
   \      0x696   0x....'....        BL       __aeabi_uidivmod
   \      0x69A   0x0AC8             LSRS     R0,R1,#+11
   \      0x69C   0x9900             LDR      R1,[SP, #+0]
   \      0x69E   0x1808             ADDS     R0,R1,R0
   \      0x6A0   0x9003             STR      R0,[SP, #+12]
    466              pagestatus = GetPageState(PAGE_ADDRESS(page));
   \      0x6A2   0x9903             LDR      R1,[SP, #+12]
   \      0x6A4   0x2080             MOVS     R0,#+128
   \      0x6A6   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x6A8   0x4341             MULS     R1,R0,R1
   \      0x6AA   0x9100             STR      R1,[SP, #+0]
   \      0x6AC   0x0030             MOVS     R0,R6
   \      0x6AE   0x6821             LDR      R1,[R4, #+0]
   \      0x6B0   0x0289             LSLS     R1,R1,#+10
   \      0x6B2   0x4029             ANDS     R1,R1,R5
   \      0x6B4   0x....'....        BL       __aeabi_uidiv
   \      0x6B8   0x6821             LDR      R1,[R4, #+0]
   \      0x6BA   0x0289             LSLS     R1,R1,#+10
   \      0x6BC   0x4029             ANDS     R1,R1,R5
   \      0x6BE   0x4348             MULS     R0,R1,R0
   \      0x6C0   0x9900             LDR      R1,[SP, #+0]
   \      0x6C2   0x1808             ADDS     R0,R1,R0
   \      0x6C4   0x2180             MOVS     R1,#+128
   \      0x6C6   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x6C8   0x1840             ADDS     R0,R0,R1
   \      0x6CA   0x....'....        BL       GetPageState
   \      0x6CE   0x4669             MOV      R1,SP
   \      0x6D0   0x7208             STRB     R0,[R1, #+8]
    467          
    468              /* Check if page is valid state */
    469              if (pagestatus == STATE_PAGE_VALID)
   \      0x6D2   0x4668             MOV      R0,SP
   \      0x6D4   0x7A00             LDRB     R0,[R0, #+8]
   \      0x6D6   0x2803             CMP      R0,#+3
   \      0x6D8   0xD105             BNE      ??EE_Init_40
    470              {
    471                /* Update uhNbWrittenElements with number of elements in full page */
    472                uhNbWrittenElements += NB_MAX_ELEMENTS_BY_PAGE;
   \      0x6DA   0x8838             LDRH     R0,[R7, #+0]
   \      0x6DC   0x30FC             ADDS     R0,R0,#+252
   \      0x6DE   0x8038             STRH     R0,[R7, #+0]
    473          
    474                /* Keep index of first valid page */
    475                firstvalidpage = page;
   \      0x6E0   0x9803             LDR      R0,[SP, #+12]
   \      0x6E2   0x9006             STR      R0,[SP, #+24]
   \      0x6E4   0xE7AA             B        ??EE_Init_38
    476              }
    477              else
    478              {
    479                /* Error: Pages sequence is not consistent */
    480                return EE_INVALID_PAGE_SEQUENCE;
   \                     ??EE_Init_40: (+1)
   \      0x6E6   0x200A             MOVS     R0,#+10
   \      0x6E8   0xE08A             B        ??EE_Init_3
    481              }
    482            }
    483          
    484            /*********************************************************************/
    485            /* Step 7: Ensure empty pages are erased                             */
    486            /*********************************************************************/
    487            /* Ensure all pages after active page, until first valid page, are erased */
    488            page = FOLLOWING_PAGE(ubCurrentActivePage);
   \                     ??EE_Init_39: (+1)
   \      0x6EA   0x....             LDR      R0,??DataTable5
   \      0x6EC   0x7807             LDRB     R7,[R0, #+0]
   \      0x6EE   0x0030             MOVS     R0,R6
   \      0x6F0   0x6821             LDR      R1,[R4, #+0]
   \      0x6F2   0x0289             LSLS     R1,R1,#+10
   \      0x6F4   0x4029             ANDS     R1,R1,R5
   \      0x6F6   0x....'....        BL       __aeabi_uidivmod
   \      0x6FA   0x0AC8             LSRS     R0,R1,#+11
   \      0x6FC   0x1A38             SUBS     R0,R7,R0
   \      0x6FE   0x1C40             ADDS     R0,R0,#+1
   \      0x700   0x210A             MOVS     R1,#+10
   \      0x702   0x....'....        BL       __aeabi_uidivmod
   \      0x706   0x000F             MOVS     R7,R1
   \      0x708   0x0030             MOVS     R0,R6
   \      0x70A   0x6821             LDR      R1,[R4, #+0]
   \      0x70C   0x0289             LSLS     R1,R1,#+10
   \      0x70E   0x4029             ANDS     R1,R1,R5
   \      0x710   0x....'....        BL       __aeabi_uidivmod
   \      0x714   0x0AC8             LSRS     R0,R1,#+11
   \      0x716   0x0039             MOVS     R1,R7
   \      0x718   0x180F             ADDS     R7,R1,R0
    489            pageaddress = PAGE_ADDRESS(page);
   \      0x71A   0x2180             MOVS     R1,#+128
   \      0x71C   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x71E   0x4379             MULS     R1,R7,R1
   \      0x720   0x9100             STR      R1,[SP, #+0]
   \      0x722   0x0030             MOVS     R0,R6
   \      0x724   0x6821             LDR      R1,[R4, #+0]
   \      0x726   0x0289             LSLS     R1,R1,#+10
   \      0x728   0x4029             ANDS     R1,R1,R5
   \      0x72A   0x....'....        BL       __aeabi_uidiv
   \      0x72E   0x6821             LDR      R1,[R4, #+0]
   \      0x730   0x0289             LSLS     R1,R1,#+10
   \      0x732   0x4029             ANDS     R1,R1,R5
   \      0x734   0x4348             MULS     R0,R1,R0
   \      0x736   0x9900             LDR      R1,[SP, #+0]
   \      0x738   0x1808             ADDS     R0,R1,R0
   \      0x73A   0x2180             MOVS     R1,#+128
   \      0x73C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x73E   0x1840             ADDS     R0,R0,R1
   \      0x740   0x9004             STR      R0,[SP, #+16]
    490          
    491            while (page != firstvalidpage)
   \                     ??EE_Init_41: (+1)
   \      0x742   0x9806             LDR      R0,[SP, #+24]
   \      0x744   0x4287             CMP      R7,R0
   \      0x746   0xD045             BEQ      ??EE_Init_42
    492            {
    493              /* Check if page erase has to be forced unconditionally (default case) */
    494              if (EraseType == EE_FORCED_ERASE)
   \      0x748   0xA80E             ADD      R0,SP,#+56
   \      0x74A   0x7800             LDRB     R0,[R0, #+0]
   \      0x74C   0x2800             CMP      R0,#+0
   \      0x74E   0xD107             BNE      ??EE_Init_43
    495              {
    496                /* Force page erase independently of its content */
    497                if (FI_PageErase(page, 1U) != EE_OK)
   \      0x750   0x2101             MOVS     R1,#+1
   \      0x752   0x0038             MOVS     R0,R7
   \      0x754   0x....'....        BL       FI_PageErase
   \      0x758   0x2800             CMP      R0,#+0
   \      0x75A   0xD010             BEQ      ??EE_Init_44
    498                {
    499                  return EE_ERASE_ERROR;
   \      0x75C   0x2001             MOVS     R0,#+1
   \      0x75E   0xE04F             B        ??EE_Init_3
    500                }
    501              }
    502              else /* EraseType == EE_CONDITIONAL_ERASE */
    503              {
    504                /* Check if page is fully erased */
    505                if (VerifyPageFullyErased(pageaddress, PAGE_SIZE) == EE_PAGE_NOTERASED)
   \                     ??EE_Init_43: (+1)
   \      0x760   0x2180             MOVS     R1,#+128
   \      0x762   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x764   0x9804             LDR      R0,[SP, #+16]
   \      0x766   0x....'....        BL       VerifyPageFullyErased
   \      0x76A   0x2810             CMP      R0,#+16
   \      0x76C   0xD107             BNE      ??EE_Init_44
    506                {
    507                  /* Erase pages if not fully erased */
    508                  if (FI_PageErase(page, 1U) != EE_OK)
   \      0x76E   0x2101             MOVS     R1,#+1
   \      0x770   0x0038             MOVS     R0,R7
   \      0x772   0x....'....        BL       FI_PageErase
   \      0x776   0x2800             CMP      R0,#+0
   \      0x778   0xD001             BEQ      ??EE_Init_44
    509                  {
    510                    return EE_ERASE_ERROR;
   \      0x77A   0x2001             MOVS     R0,#+1
   \      0x77C   0xE040             B        ??EE_Init_3
    511                  }
    512                }
    513              }
    514          
    515              /* Increment page index among circular pages list, to get first page to erased */
    516              page = FOLLOWING_PAGE(page);
   \                     ??EE_Init_44: (+1)
   \      0x77E   0x0030             MOVS     R0,R6
   \      0x780   0x6821             LDR      R1,[R4, #+0]
   \      0x782   0x0289             LSLS     R1,R1,#+10
   \      0x784   0x4029             ANDS     R1,R1,R5
   \      0x786   0x....'....        BL       __aeabi_uidivmod
   \      0x78A   0x0AC8             LSRS     R0,R1,#+11
   \      0x78C   0x1A38             SUBS     R0,R7,R0
   \      0x78E   0x1C40             ADDS     R0,R0,#+1
   \      0x790   0x210A             MOVS     R1,#+10
   \      0x792   0x....'....        BL       __aeabi_uidivmod
   \      0x796   0x000F             MOVS     R7,R1
   \      0x798   0x0030             MOVS     R0,R6
   \      0x79A   0x6821             LDR      R1,[R4, #+0]
   \      0x79C   0x0289             LSLS     R1,R1,#+10
   \      0x79E   0x4029             ANDS     R1,R1,R5
   \      0x7A0   0x....'....        BL       __aeabi_uidivmod
   \      0x7A4   0x0AC8             LSRS     R0,R1,#+11
   \      0x7A6   0x0039             MOVS     R1,R7
   \      0x7A8   0x180F             ADDS     R7,R1,R0
    517              pageaddress = PAGE_ADDRESS(page);
   \      0x7AA   0x2180             MOVS     R1,#+128
   \      0x7AC   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x7AE   0x4379             MULS     R1,R7,R1
   \      0x7B0   0x9100             STR      R1,[SP, #+0]
   \      0x7B2   0x0030             MOVS     R0,R6
   \      0x7B4   0x6821             LDR      R1,[R4, #+0]
   \      0x7B6   0x0289             LSLS     R1,R1,#+10
   \      0x7B8   0x4029             ANDS     R1,R1,R5
   \      0x7BA   0x....'....        BL       __aeabi_uidiv
   \      0x7BE   0x6821             LDR      R1,[R4, #+0]
   \      0x7C0   0x0289             LSLS     R1,R1,#+10
   \      0x7C2   0x4029             ANDS     R1,R1,R5
   \      0x7C4   0x4348             MULS     R0,R1,R0
   \      0x7C6   0x9900             LDR      R1,[SP, #+0]
   \      0x7C8   0x1808             ADDS     R0,R1,R0
   \      0x7CA   0x2180             MOVS     R1,#+128
   \      0x7CC   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x7CE   0x1840             ADDS     R0,R0,R1
   \      0x7D0   0x9004             STR      R0,[SP, #+16]
   \      0x7D2   0xE7B6             B        ??EE_Init_41
    518            }
    519           
    520            /* To keep their coherency, flush the caches if needed depending on the product */
    521            FI_CacheFlush();
   \                     ??EE_Init_42: (+1)
   \      0x7D4   0x....'....        BL       FI_CacheFlush
    522          
    523            /*********************************************************************/
    524            /* Step 8: Perform dummy write '0' to get rid of potential           */
    525            /*         instability of line value 0xFFFFFFFF consecutive to a     */
    526            /*         reset during write here                                   */
    527            /*         Only needed if recovery transfer did not occured          */
    528            /*********************************************************************/
    529            if (recoverytransfer == 0U)
   \      0x7D8   0x980B             LDR      R0,[SP, #+44]
   \      0x7DA   0x2800             CMP      R0,#+0
   \      0x7DC   0xD10F             BNE      ??EE_Init_45
    530            {
    531          
    532          #ifdef DUALCORE_FLASH_SHARING
    533              status = VerifyPagesFullWriteVariable(0U, 0U, EE_INIT_WRITE);
    534              
    535              /* The dummy write can be skipped in case pages are full
    536                because in this case potential instability can not happen */
    537              if ((status != EE_OK) && (status != EE_PAGE_FULL))
    538              {
    539                return EE_WRITE_ERROR;
    540              }
    541          #else
    542              status = VerifyPagesFullWriteVariable(0U, 0U);
   \      0x7DE   0x2100             MOVS     R1,#+0
   \      0x7E0   0x2000             MOVS     R0,#+0
   \      0x7E2   0x....'....        BL       VerifyPagesFullWriteVariable
   \      0x7E6   0x4669             MOV      R1,SP
   \      0x7E8   0x8148             STRH     R0,[R1, #+10]
    543              
    544              /* The dummy write can be skipped in case pages are full
    545                 because in this case potential instability can not happen */
    546              if ((status != EE_OK) && (status != EE_PAGE_FULL))
   \      0x7EA   0x9802             LDR      R0,[SP, #+8]
   \      0x7EC   0x1400             ASRS     R0,R0,#+16
   \      0x7EE   0x2800             CMP      R0,#+0
   \      0x7F0   0xD005             BEQ      ??EE_Init_45
   \      0x7F2   0x9802             LDR      R0,[SP, #+8]
   \      0x7F4   0x1400             ASRS     R0,R0,#+16
   \      0x7F6   0x2812             CMP      R0,#+18
   \      0x7F8   0xD001             BEQ      ??EE_Init_45
    547              {
    548                return EE_WRITE_ERROR;
   \      0x7FA   0x2002             MOVS     R0,#+2
   \      0x7FC   0xE000             B        ??EE_Init_3
    549              }
    550          #endif
    551            }
    552          
    553            return EE_OK;
   \                     ??EE_Init_45: (+1)
   \      0x7FE   0x2000             MOVS     R0,#+0
   \                     ??EE_Init_3: (+1)
   \      0x800   0xB00F             ADD      SP,SP,#+60
   \      0x802   0xBDF0             POP      {R4-R7,PC}       ;; return
    554          }
    555          
    556          /**
    557            * @brief  Erases all flash pages of eeprom emulation, and set first page
    558            *         header as ACTIVE.
    559            * @note   This function can be called the very first time eeprom emulation is
    560            *         used, to prepare flash pages for eeprom emulation with empty eeprom
    561                      variables. It can also be called at any time, to flush all eeprom
    562            *         variables.
    563            * @param  EraseType: Type of erase to apply on page requiring to be erased.
    564            *         This parameter can be one of the following values:
    565            *          @arg @ref EE_FORCED_ERASE      pages to erase are erased unconditionnally
    566            *          @arg @ref EE_CONDITIONAL_ERASE pages to erase are erased only if not fully erased
    567            * @retval EE_Status
    568            *           - EE_OK: on success
    569            *           - EE error code: if an error occurs
    570            */

   \                                 In section .text, align 2, keep-with-next
    571          EE_Status EE_Format(EE_Erase_type EraseType)
    572          {
   \                     EE_Format: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    573            uint32_t page = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    574          
    575            /* Check if the configuration is 128-bits bank or 2*64-bits bank */
    576            if (FI_CheckBankConfig() != EE_OK)
   \        0x8   0x....'....        BL       FI_CheckBankConfig
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD001             BEQ      ??EE_Format_0
    577            {
    578              return EE_INVALID_BANK_CFG;
   \       0x10   0x200E             MOVS     R0,#+14
   \       0x12   0xE067             B        ??EE_Format_1
    579            }
    580            
    581            #ifdef DUALCORE_FLASH_SHARING
    582            /* Inform CPU2 about Erase Activity */
    583            SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_ON);
    584            #endif
    585            
    586            /* Erase All Pages */
    587            for (page = START_PAGE; page < (START_PAGE + PAGES_NUMBER); page++)
   \                     ??EE_Format_0: (+1)
   \       0x14   0x26FF             MOVS     R6,#+255
   \       0x16   0x02B6             LSLS     R6,R6,#+10       ;; #+261120
   \       0x18   0x....             LDR      R5,??DataTable10  ;; 0x1fff75e0
   \       0x1A   0x27D8             MOVS     R7,#+216
   \       0x1C   0x027F             LSLS     R7,R7,#+9        ;; #+110592
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0x6829             LDR      R1,[R5, #+0]
   \       0x22   0x0289             LSLS     R1,R1,#+10
   \       0x24   0x4031             ANDS     R1,R1,R6
   \       0x26   0x....'....        BL       __aeabi_uidivmod
   \       0x2A   0x0ACC             LSRS     R4,R1,#+11
   \                     ??EE_Format_2: (+1)
   \       0x2C   0x0038             MOVS     R0,R7
   \       0x2E   0x6829             LDR      R1,[R5, #+0]
   \       0x30   0x0289             LSLS     R1,R1,#+10
   \       0x32   0x4031             ANDS     R1,R1,R6
   \       0x34   0x....'....        BL       __aeabi_uidivmod
   \       0x38   0x0AC8             LSRS     R0,R1,#+11
   \       0x3A   0x300A             ADDS     R0,R0,#+10
   \       0x3C   0x4284             CMP      R4,R0
   \       0x3E   0xD22E             BCS      ??EE_Format_3
    588            {
    589              /* Check if page erase has to be forced unconditionally (default case) */
    590              if (EraseType == EE_FORCED_ERASE)
   \       0x40   0x4668             MOV      R0,SP
   \       0x42   0x7A00             LDRB     R0,[R0, #+8]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD107             BNE      ??EE_Format_4
    591              {
    592                /* Force page erase independently of its content */
    593                if (FI_PageErase(page, 1U) != EE_OK)
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x....'....        BL       FI_PageErase
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD022             BEQ      ??EE_Format_5
    594                {
    595                  #ifdef DUALCORE_FLASH_SHARING
    596                  /* Inform CPU2 about end of Erase Activity */
    597                  SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_OFF);
    598                  #endif
    599                  return EE_ERASE_ERROR;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE045             B        ??EE_Format_1
    600                }
    601              }
    602              else /* EraseType == EE_CONDITIONAL_ERASE */
    603              {
    604                /* Check if Page is not yet fully erased */
    605                if (VerifyPageFullyErased(PAGE_ADDRESS(page), PAGE_SIZE) == EE_PAGE_NOTERASED)
   \                     ??EE_Format_4: (+1)
   \       0x58   0x2180             MOVS     R1,#+128
   \       0x5A   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x5C   0x9101             STR      R1,[SP, #+4]
   \       0x5E   0x4361             MULS     R1,R4,R1
   \       0x60   0x9100             STR      R1,[SP, #+0]
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0x6829             LDR      R1,[R5, #+0]
   \       0x66   0x0289             LSLS     R1,R1,#+10
   \       0x68   0x4031             ANDS     R1,R1,R6
   \       0x6A   0x....'....        BL       __aeabi_uidiv
   \       0x6E   0x6829             LDR      R1,[R5, #+0]
   \       0x70   0x0289             LSLS     R1,R1,#+10
   \       0x72   0x4031             ANDS     R1,R1,R6
   \       0x74   0x4348             MULS     R0,R1,R0
   \       0x76   0x9900             LDR      R1,[SP, #+0]
   \       0x78   0x1808             ADDS     R0,R1,R0
   \       0x7A   0x2180             MOVS     R1,#+128
   \       0x7C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x7E   0x1840             ADDS     R0,R0,R1
   \       0x80   0x9901             LDR      R1,[SP, #+4]
   \       0x82   0x....'....        BL       VerifyPageFullyErased
   \       0x86   0x2810             CMP      R0,#+16
   \       0x88   0xD107             BNE      ??EE_Format_5
    606                {
    607                  /* Erase the page */
    608                  /* If Erase operation was failed, a Flash error code is returned */
    609                  if (FI_PageErase(page, 1U) != EE_OK)
   \       0x8A   0x2101             MOVS     R1,#+1
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x....'....        BL       FI_PageErase
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ      ??EE_Format_5
    610                  {
    611                    #ifdef DUALCORE_FLASH_SHARING
    612                    /* Inform CPU2 about end of Erase Activity */
    613                    SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_OFF);
    614                    #endif
    615                    return EE_ERASE_ERROR;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE024             B        ??EE_Format_1
    616                  }
    617                }
    618              }
    619            }
   \                     ??EE_Format_5: (+1)
   \       0x9A   0x1C64             ADDS     R4,R4,#+1
   \       0x9C   0xE7C6             B        ??EE_Format_2
    620            
    621            /* To keep their coherency, flush the caches if needed depending on the product */
    622            FI_CacheFlush();
   \                     ??EE_Format_3: (+1)
   \       0x9E   0x....'....        BL       FI_CacheFlush
    623            
    624            #ifdef DUALCORE_FLASH_SHARING
    625            /* Inform CPU2 about end of Erase Activity */
    626            SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_OFF);
    627            #endif
    628          
    629            /* Set first Page in Active State */
    630            /* If program operation was failed, a Flash error code is returned */
    631            if (SetPageState(START_PAGE, STATE_PAGE_ACTIVE) != EE_OK)
   \       0xA2   0x2102             MOVS     R1,#+2
   \       0xA4   0x9100             STR      R1,[SP, #+0]
   \       0xA6   0x0038             MOVS     R0,R7
   \       0xA8   0x6829             LDR      R1,[R5, #+0]
   \       0xAA   0x0289             LSLS     R1,R1,#+10
   \       0xAC   0x4031             ANDS     R1,R1,R6
   \       0xAE   0x....'....        BL       __aeabi_uidivmod
   \       0xB2   0x0AC8             LSRS     R0,R1,#+11
   \       0xB4   0x9900             LDR      R1,[SP, #+0]
   \       0xB6   0x....'....        BL       SetPageState
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD001             BEQ      ??EE_Format_6
    632            {
    633              return EE_WRITE_ERROR;
   \       0xBE   0x2002             MOVS     R0,#+2
   \       0xC0   0xE010             B        ??EE_Format_1
    634            }
    635          
    636            /* Reset global variables */
    637            uhNbWrittenElements = (uint16_t)0U;
   \                     ??EE_Format_6: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x....             LDR      R1,??DataTable3
   \       0xC6   0x8008             STRH     R0,[R1, #+0]
    638            ubCurrentActivePage = START_PAGE;
   \       0xC8   0x0038             MOVS     R0,R7
   \       0xCA   0x6829             LDR      R1,[R5, #+0]
   \       0xCC   0x0289             LSLS     R1,R1,#+10
   \       0xCE   0x400E             ANDS     R6,R6,R1
   \       0xD0   0x0031             MOVS     R1,R6
   \       0xD2   0x....'....        BL       __aeabi_uidivmod
   \       0xD6   0x0AC8             LSRS     R0,R1,#+11
   \       0xD8   0x....             LDR      R1,??DataTable5
   \       0xDA   0x7008             STRB     R0,[R1, #+0]
    639            uwAddressNextWrite = PAGE_HEADER_SIZE; /* Initialize write position just after page header */
   \       0xDC   0x2020             MOVS     R0,#+32
   \       0xDE   0x....             LDR      R1,??DataTable3_1
   \       0xE0   0x6008             STR      R0,[R1, #+0]
    640          
    641            return EE_OK;
   \       0xE2   0x2000             MOVS     R0,#+0
   \                     ??EE_Format_1: (+1)
   \       0xE4   0xBDFE             POP      {R1-R7,PC}       ;; return
    642          }
    643          
    644          #if defined(EE_ACCESS_32BITS)
    645          /**
    646            * @brief  Returns the last stored variable data, if found, which correspond to
    647            *         the passed virtual address
    648            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    649            * @param  pData Variable containing the 32bits read variable value
    650            * @retval EE_Status
    651            *           - EE_OK: if variable was found
    652            *           - EE error code: if an error occurs
    653            */

   \                                 In section .text, align 2, keep-with-next
    654          EE_Status EE_ReadVariable32bits(uint16_t VirtAddress, uint32_t* pData)
    655          {
   \                     EE_ReadVariable32bits: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    656            if((VirtAddress != 0x0000) && (VirtAddress != 0xFFFF))
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00F             BEQ      ??EE_ReadVariable32bits_0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x....             LDR      R1,??DataTable11  ;; 0xffff
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD00A             BEQ      ??EE_ReadVariable32bits_0
    657            {
    658              EE_DATA_TYPE datatmp = 0U;
   \       0x18   0x2600             MOVS     R6,#+0
   \       0x1A   0x9600             STR      R6,[SP, #+0]
    659              EE_Status status = EE_OK;
    660          
    661              /* Read variable of size EE_DATA_TYPE, then cast it to 32bits */
    662              status = ReadVariable(VirtAddress, &datatmp);
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x....'....        BL       ReadVariable
    663              *pData = (uint32_t) datatmp;
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x6029             STR      R1,[R5, #+0]
    664          
    665              return status;
   \       0x2A   0xB200             SXTH     R0,R0
   \       0x2C   0xE000             B        ??EE_ReadVariable32bits_1
    666            }
    667            else
    668            {
    669              return EE_INVALID_VIRTUALADDRESS;
   \                     ??EE_ReadVariable32bits_0: (+1)
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??EE_ReadVariable32bits_1: (+1)
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    670            } 
    671          }
    672          #endif
    673          
    674          /**
    675            * @brief  Returns the last stored variable data, if found, which correspond to
    676            *         the passed virtual address
    677            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    678            * @param  pData Variable containing the 16bits read variable value
    679            * @retval EE_Status
    680            *           - EE_OK: if variable was found
    681            *           - EE error code: if an error occurs
    682            */

   \                                 In section .text, align 2, keep-with-next
    683          EE_Status EE_ReadVariable16bits(uint16_t VirtAddress, uint16_t* pData)
    684          {
   \                     EE_ReadVariable16bits: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    685            if((VirtAddress != 0x0000) && (VirtAddress != 0xFFFF))
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00F             BEQ      ??EE_ReadVariable16bits_0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x....             LDR      R1,??DataTable11  ;; 0xffff
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD00A             BEQ      ??EE_ReadVariable16bits_0
    686            {
    687              EE_DATA_TYPE datatmp = 0U;
   \       0x18   0x2600             MOVS     R6,#+0
   \       0x1A   0x9600             STR      R6,[SP, #+0]
    688              EE_Status status = EE_OK;
    689          
    690              /* Read variable of size EE_DATA_TYPE, then cast it to 16bits */
    691              status = ReadVariable(VirtAddress, &datatmp);
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x....'....        BL       ReadVariable
    692              *pData = (uint16_t) datatmp;
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x8029             STRH     R1,[R5, #+0]
    693          
    694              return status;
   \       0x2A   0xB200             SXTH     R0,R0
   \       0x2C   0xE000             B        ??EE_ReadVariable16bits_1
    695            }
    696            else
    697            {
    698              return EE_INVALID_VIRTUALADDRESS;
   \                     ??EE_ReadVariable16bits_0: (+1)
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??EE_ReadVariable16bits_1: (+1)
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    699            } 
    700          }
    701          
    702          /**
    703            * @brief  Returns the last stored variable data, if found, which correspond to
    704            *         the passed virtual address
    705            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    706            * @param  pData Variable containing the 8bits read variable value
    707            * @retval EE_Status
    708            *           - EE_OK: if variable was found
    709            *           - EE error code: if an error occurs
    710            */

   \                                 In section .text, align 2, keep-with-next
    711          EE_Status EE_ReadVariable8bits(uint16_t VirtAddress, uint8_t* pData)
    712          {
   \                     EE_ReadVariable8bits: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    713            if((VirtAddress != 0x0000) && (VirtAddress != 0xFFFF))
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00F             BEQ      ??EE_ReadVariable8bits_0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x....             LDR      R1,??DataTable11  ;; 0xffff
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD00A             BEQ      ??EE_ReadVariable8bits_0
    714            {
    715              EE_DATA_TYPE datatmp = 0U;
   \       0x18   0x2600             MOVS     R6,#+0
   \       0x1A   0x9600             STR      R6,[SP, #+0]
    716              EE_Status status = EE_OK;
    717          
    718              /* Read variable of size EE_DATA_TYPE, then cast it to 8bits */
    719              status = ReadVariable(VirtAddress, &datatmp);
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x....'....        BL       ReadVariable
    720              *pData = (uint8_t) datatmp;
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x7029             STRB     R1,[R5, #+0]
    721          
    722              return status;
   \       0x2A   0xB200             SXTH     R0,R0
   \       0x2C   0xE000             B        ??EE_ReadVariable8bits_1
    723            }
    724            else
    725            {
    726              return EE_INVALID_VIRTUALADDRESS;
   \                     ??EE_ReadVariable8bits_0: (+1)
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??EE_ReadVariable8bits_1: (+1)
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    727            } 
    728          }
    729          
    730          #if defined(EE_ACCESS_32BITS)
    731          /**
    732            * @brief  Writes/updates variable data in EEPROM.
    733            *         Trig internal Pages transfer if half of the pages are full.
    734            * @warning This function is not reentrant
    735            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    736            * @param  Data 32bits data to be written
    737            * @retval EE_Status
    738            *           - EE_OK: on success
    739            *           - EE_CLEANUP_REQUIRED: success and user has to trig flash pages cleanup
    740            *           - EE error code: if an error occurs
    741            */

   \                                 In section .text, align 2, keep-with-next
    742          EE_Status EE_WriteVariable32bits(uint16_t VirtAddress, uint32_t Data)
    743          {
   \                     EE_WriteVariable32bits: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    744            if((VirtAddress != 0x0000) && (VirtAddress != 0xFFFF))
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00A             BEQ      ??EE_WriteVariable32bits_0
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x....             LDR      R1,??DataTable11  ;; 0xffff
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD005             BEQ      ??EE_WriteVariable32bits_0
    745            {
    746              return WriteVariable(VirtAddress, (EE_DATA_TYPE) Data);
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x....'....        BL       WriteVariable
   \       0x22   0xE000             B        ??EE_WriteVariable32bits_1
    747            }
    748            else
    749            {
    750              return EE_INVALID_VIRTUALADDRESS;
   \                     ??EE_WriteVariable32bits_0: (+1)
   \       0x24   0x2008             MOVS     R0,#+8
   \                     ??EE_WriteVariable32bits_1: (+1)
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    751            } 
    752          }
    753          #endif
    754          
    755          /**
    756            * @brief  Writes/updates variable data in EEPROM.
    757            *         Trig internal Pages transfer if half of the pages are full.
    758            * @warning This function is not reentrant
    759            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    760            * @param  Data 16bits data to be written
    761            * @retval EE_Status
    762            *           - EE_OK: on success
    763            *           - EE_CLEANUP_REQUIRED: success and user has to trig flash pages cleanup
    764            *           - EE error code: if an error occurs
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          EE_Status EE_WriteVariable16bits(uint16_t VirtAddress, uint16_t Data)
    767          {
   \                     EE_WriteVariable16bits: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    768            if((VirtAddress != 0x0000) && (VirtAddress != 0xFFFF))
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00B             BEQ      ??EE_WriteVariable16bits_0
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x....             LDR      R1,??DataTable11  ;; 0xffff
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD006             BEQ      ??EE_WriteVariable16bits_0
    769            {
    770              return WriteVariable(VirtAddress, (EE_DATA_TYPE) Data);
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xB289             UXTH     R1,R1
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x....'....        BL       WriteVariable
   \       0x24   0xE000             B        ??EE_WriteVariable16bits_1
    771            }
    772            else
    773            {
    774              return EE_INVALID_VIRTUALADDRESS;
   \                     ??EE_WriteVariable16bits_0: (+1)
   \       0x26   0x2008             MOVS     R0,#+8
   \                     ??EE_WriteVariable16bits_1: (+1)
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    775            }    
    776          }
    777          
    778          /**
    779            * @brief  Writes/updates variable data in EEPROM.
    780            *         Trig internal Pages transfer if half of the pages are full.
    781            * @warning This function is not reentrant
    782            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    783            * @param  Data 8bits data to be written
    784            * @retval EE_Status
    785            *           - EE_OK: on success
    786            *           - EE_CLEANUP_REQUIRED: success and user has to trig flash pages cleanup
    787            *           - EE error code: if an error occurs
    788            */

   \                                 In section .text, align 2, keep-with-next
    789          EE_Status EE_WriteVariable8bits(uint16_t VirtAddress, uint8_t Data)
    790          {
   \                     EE_WriteVariable8bits: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    791            if((VirtAddress != 0x0000) && (VirtAddress != 0xFFFF))
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00B             BEQ      ??EE_WriteVariable8bits_0
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x....             LDR      R1,??DataTable11  ;; 0xffff
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD006             BEQ      ??EE_WriteVariable8bits_0
    792            {
    793              return WriteVariable(VirtAddress, (EE_DATA_TYPE) Data);
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xB2C9             UXTB     R1,R1
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x....'....        BL       WriteVariable
   \       0x24   0xE000             B        ??EE_WriteVariable8bits_1
    794            }
    795            else
    796            {
    797              return EE_INVALID_VIRTUALADDRESS;
   \                     ??EE_WriteVariable8bits_0: (+1)
   \       0x26   0x2008             MOVS     R0,#+8
   \                     ??EE_WriteVariable8bits_1: (+1)
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    798            } 
    799          }
    800          
    801          /**
    802            * @brief  Erase group of pages which are erasing state, in polling mode.
    803            *         Could be either first half or second half of total pages number.
    804            * @note   This function should be called when EE_WriteVariableXXbits has
    805            *         returned EE_CLEANUP_REQUIRED status (and only in that case)
    806            * @retval EE_Status
    807            *           - EE_OK: in case of success
    808            *           - EE error code: if an error occurs
    809            */

   \                                 In section .text, align 2, keep-with-next
    810          EE_Status EE_CleanUp(void)
    811          {
   \                     EE_CleanUp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
    812            uint32_t firstpage = 0U, page = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x9000             STR      R0,[SP, #+0]
    813            uint32_t firstpageaddress = 0U, pageaddress = 0U;
   \        0xA   0x9003             STR      R0,[SP, #+12]
   \        0xC   0x9002             STR      R0,[SP, #+8]
    814            EE_State_type firstpagestatus = STATE_PAGE_INVALID, pagestatus = STATE_PAGE_INVALID;
   \        0xE   0x2005             MOVS     R0,#+5
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x7151             STRB     R1,[R2, #+5]
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x7108             STRB     R0,[R1, #+4]
    815          
    816            /* Check first half and second half page group */
    817            for (firstpage = START_PAGE; firstpage < (START_PAGE + PAGES_NUMBER); firstpage += (PAGES_NUMBER / 2U))
   \       0x1A   0x20D8             MOVS     R0,#+216
   \       0x1C   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x1E   0x....             LDR      R1,??DataTable10  ;; 0x1fff75e0
   \       0x20   0x6809             LDR      R1,[R1, #+0]
   \       0x22   0x028A             LSLS     R2,R1,#+10
   \       0x24   0x21FF             MOVS     R1,#+255
   \       0x26   0x0289             LSLS     R1,R1,#+10       ;; #+261120
   \       0x28   0x4011             ANDS     R1,R1,R2
   \       0x2A   0x....'....        BL       __aeabi_uidivmod
   \       0x2E   0x0ACC             LSRS     R4,R1,#+11
   \                     ??EE_CleanUp_0: (+1)
   \       0x30   0x26FF             MOVS     R6,#+255
   \       0x32   0x02B6             LSLS     R6,R6,#+10       ;; #+261120
   \       0x34   0x....             LDR      R5,??DataTable10  ;; 0x1fff75e0
   \       0x36   0x20D8             MOVS     R0,#+216
   \       0x38   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0x0289             LSLS     R1,R1,#+10
   \       0x3E   0x4031             ANDS     R1,R1,R6
   \       0x40   0x....'....        BL       __aeabi_uidivmod
   \       0x44   0x0AC8             LSRS     R0,R1,#+11
   \       0x46   0x300A             ADDS     R0,R0,#+10
   \       0x48   0x4284             CMP      R4,R0
   \       0x4A   0xD251             BCS      ??EE_CleanUp_1
    818            {
    819              /* Check status of first page of the group */
    820              firstpageaddress = PAGE_ADDRESS(firstpage);
   \       0x4C   0x2780             MOVS     R7,#+128
   \       0x4E   0x013F             LSLS     R7,R7,#+4        ;; #+2048
   \       0x50   0x4367             MULS     R7,R4,R7
   \       0x52   0x20D8             MOVS     R0,#+216
   \       0x54   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x56   0x6829             LDR      R1,[R5, #+0]
   \       0x58   0x0289             LSLS     R1,R1,#+10
   \       0x5A   0x4031             ANDS     R1,R1,R6
   \       0x5C   0x....'....        BL       __aeabi_uidiv
   \       0x60   0x6829             LDR      R1,[R5, #+0]
   \       0x62   0x0289             LSLS     R1,R1,#+10
   \       0x64   0x4031             ANDS     R1,R1,R6
   \       0x66   0x4348             MULS     R0,R1,R0
   \       0x68   0x1838             ADDS     R0,R7,R0
   \       0x6A   0x2180             MOVS     R1,#+128
   \       0x6C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x6E   0x1840             ADDS     R0,R0,R1
   \       0x70   0x9003             STR      R0,[SP, #+12]
    821              firstpagestatus = GetPageState(firstpageaddress);
   \       0x72   0x9803             LDR      R0,[SP, #+12]
   \       0x74   0x....'....        BL       GetPageState
   \       0x78   0x4669             MOV      R1,SP
   \       0x7A   0x7148             STRB     R0,[R1, #+5]
    822          
    823              /* If first page of the group is erasing state, check that all other pages
    824              of the group are also erasing state */
    825              if (firstpagestatus == STATE_PAGE_ERASING)
   \       0x7C   0x4668             MOV      R0,SP
   \       0x7E   0x7940             LDRB     R0,[R0, #+5]
   \       0x80   0x2804             CMP      R0,#+4
   \       0x82   0xD133             BNE      ??EE_CleanUp_2
    826              {
    827                for (page = (firstpage + 1U); page < (firstpage + (PAGES_NUMBER / 2U)); page++)
   \       0x84   0x0027             MOVS     R7,R4
   \       0x86   0x1C7F             ADDS     R7,R7,#+1
   \                     ??EE_CleanUp_3: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x1D40             ADDS     R0,R0,#+5
   \       0x8C   0x4287             CMP      R7,R0
   \       0x8E   0xD221             BCS      ??EE_CleanUp_4
    828                {
    829                  pageaddress = PAGE_ADDRESS(page);
   \       0x90   0x2180             MOVS     R1,#+128
   \       0x92   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x94   0x4379             MULS     R1,R7,R1
   \       0x96   0x9100             STR      R1,[SP, #+0]
   \       0x98   0x20D8             MOVS     R0,#+216
   \       0x9A   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x9C   0x6829             LDR      R1,[R5, #+0]
   \       0x9E   0x0289             LSLS     R1,R1,#+10
   \       0xA0   0x4031             ANDS     R1,R1,R6
   \       0xA2   0x....'....        BL       __aeabi_uidiv
   \       0xA6   0x6829             LDR      R1,[R5, #+0]
   \       0xA8   0x0289             LSLS     R1,R1,#+10
   \       0xAA   0x4031             ANDS     R1,R1,R6
   \       0xAC   0x4348             MULS     R0,R1,R0
   \       0xAE   0x9900             LDR      R1,[SP, #+0]
   \       0xB0   0x1808             ADDS     R0,R1,R0
   \       0xB2   0x2180             MOVS     R1,#+128
   \       0xB4   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0xB6   0x1840             ADDS     R0,R0,R1
   \       0xB8   0x9002             STR      R0,[SP, #+8]
    830                  pagestatus = GetPageState(pageaddress);
   \       0xBA   0x9802             LDR      R0,[SP, #+8]
   \       0xBC   0x....'....        BL       GetPageState
   \       0xC0   0x4669             MOV      R1,SP
   \       0xC2   0x7108             STRB     R0,[R1, #+4]
    831          
    832                  /* If page is not erasing, return error */
    833                  if (pagestatus != STATE_PAGE_ERASING)
   \       0xC4   0x4668             MOV      R0,SP
   \       0xC6   0x7900             LDRB     R0,[R0, #+4]
   \       0xC8   0x2804             CMP      R0,#+4
   \       0xCA   0xD001             BEQ      ??EE_CleanUp_5
    834                  {
    835                    return EE_ERROR_NOERASING_PAGE;
   \       0xCC   0x2005             MOVS     R0,#+5
   \       0xCE   0xE010             B        ??EE_CleanUp_6
    836                  }
    837                }
   \                     ??EE_CleanUp_5: (+1)
   \       0xD0   0x1C7F             ADDS     R7,R7,#+1
   \       0xD2   0xE7D9             B        ??EE_CleanUp_3
    838                
    839                #ifdef DUALCORE_FLASH_SHARING
    840                /* Inform CPU2 about Erase Activity */
    841                SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_ON);
    842                #endif
    843          
    844                /* Erase all the pages of the group */
    845                /* If erase operation fails, a Flash error code is returned */
    846                if (FI_PageErase(firstpage, PAGES_NUMBER / 2U) != EE_OK)
   \                     ??EE_CleanUp_4: (+1)
   \       0xD4   0x2105             MOVS     R1,#+5
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x....'....        BL       FI_PageErase
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD001             BEQ      ??EE_CleanUp_7
    847                {
    848                  #ifdef DUALCORE_FLASH_SHARING
    849                  /* Inform CPU2 about end of Erase Activity */
    850                  SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_OFF);
    851                  #endif
    852                  return EE_ERASE_ERROR;
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0xE006             B        ??EE_CleanUp_6
    853                }
    854                else
    855                {
    856                  #ifdef DUALCORE_FLASH_SHARING
    857                  /* Inform CPU2 about end of Erase Activity */
    858                  SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_OFF);
    859                  #endif
    860                  
    861                  /* To keep their coherency, flush the caches if needed depending on the product */
    862                  FI_CacheFlush();
   \                     ??EE_CleanUp_7: (+1)
   \       0xE4   0x....'....        BL       FI_CacheFlush
    863                  
    864                  return EE_OK;
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0xE002             B        ??EE_CleanUp_6
    865                }
    866              }
    867            }
   \                     ??EE_CleanUp_2: (+1)
   \       0xEC   0x1D64             ADDS     R4,R4,#+5
   \       0xEE   0xE79F             B        ??EE_CleanUp_0
    868          
    869            /* Error if no erasing pages group is found */
    870            return EE_ERROR_NOERASING_PAGE;
   \                     ??EE_CleanUp_1: (+1)
   \       0xF0   0x2005             MOVS     R0,#+5
   \                     ??EE_CleanUp_6: (+1)
   \       0xF2   0xB005             ADD      SP,SP,#+20
   \       0xF4   0xBDF0             POP      {R4-R7,PC}       ;; return
    871          }
    872          
    873          /**
    874            * @brief  Erase group of pages which are erasing state, in IT mode.
    875            *         Could be either first half or second half of total pages number.
    876            * @note   This function should be called when EE_WriteVariableXXbits has
    877            *         returned EE_CLEANUP_REQUIRED status (and only in that case)
    878            * @retval EE_Status
    879            *           - EE_OK: in case of success
    880            *           - EE error code: if an error occurs
    881            */

   \                                 In section .text, align 2, keep-with-next
    882          EE_Status EE_CleanUp_IT(void)
    883          {
   \                     EE_CleanUp_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
    884            uint32_t firstpage = 0U, page = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x9000             STR      R0,[SP, #+0]
    885            uint32_t firstpageaddress = 0U, pageaddress = 0U;
   \        0xA   0x9003             STR      R0,[SP, #+12]
   \        0xC   0x9002             STR      R0,[SP, #+8]
    886            EE_State_type firstpagestatus = STATE_PAGE_INVALID, pagestatus = STATE_PAGE_INVALID;
   \        0xE   0x2005             MOVS     R0,#+5
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x7151             STRB     R1,[R2, #+5]
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x7108             STRB     R0,[R1, #+4]
    887          
    888            /* Check first half and second half page group */
    889            for (firstpage = START_PAGE; firstpage < (START_PAGE + PAGES_NUMBER); firstpage += (PAGES_NUMBER / 2U))
   \       0x1A   0x20D8             MOVS     R0,#+216
   \       0x1C   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x1E   0x....             LDR      R1,??DataTable13  ;; 0x1fff75e0
   \       0x20   0x6809             LDR      R1,[R1, #+0]
   \       0x22   0x028A             LSLS     R2,R1,#+10
   \       0x24   0x21FF             MOVS     R1,#+255
   \       0x26   0x0289             LSLS     R1,R1,#+10       ;; #+261120
   \       0x28   0x4011             ANDS     R1,R1,R2
   \       0x2A   0x....'....        BL       __aeabi_uidivmod
   \       0x2E   0x0ACC             LSRS     R4,R1,#+11
   \                     ??EE_CleanUp_IT_0: (+1)
   \       0x30   0x26FF             MOVS     R6,#+255
   \       0x32   0x02B6             LSLS     R6,R6,#+10       ;; #+261120
   \       0x34   0x....             LDR      R5,??DataTable13  ;; 0x1fff75e0
   \       0x36   0x20D8             MOVS     R0,#+216
   \       0x38   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0x0289             LSLS     R1,R1,#+10
   \       0x3E   0x4031             ANDS     R1,R1,R6
   \       0x40   0x....'....        BL       __aeabi_uidivmod
   \       0x44   0x0AC8             LSRS     R0,R1,#+11
   \       0x46   0x300A             ADDS     R0,R0,#+10
   \       0x48   0x4284             CMP      R4,R0
   \       0x4A   0xD251             BCS      ??EE_CleanUp_IT_1
    890            {
    891              /* Check status of first page of the group */
    892              firstpageaddress = PAGE_ADDRESS(firstpage);
   \       0x4C   0x2780             MOVS     R7,#+128
   \       0x4E   0x013F             LSLS     R7,R7,#+4        ;; #+2048
   \       0x50   0x4367             MULS     R7,R4,R7
   \       0x52   0x20D8             MOVS     R0,#+216
   \       0x54   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x56   0x6829             LDR      R1,[R5, #+0]
   \       0x58   0x0289             LSLS     R1,R1,#+10
   \       0x5A   0x4031             ANDS     R1,R1,R6
   \       0x5C   0x....'....        BL       __aeabi_uidiv
   \       0x60   0x6829             LDR      R1,[R5, #+0]
   \       0x62   0x0289             LSLS     R1,R1,#+10
   \       0x64   0x4031             ANDS     R1,R1,R6
   \       0x66   0x4348             MULS     R0,R1,R0
   \       0x68   0x1838             ADDS     R0,R7,R0
   \       0x6A   0x2180             MOVS     R1,#+128
   \       0x6C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x6E   0x1840             ADDS     R0,R0,R1
   \       0x70   0x9003             STR      R0,[SP, #+12]
    893              firstpagestatus = GetPageState(firstpageaddress);
   \       0x72   0x9803             LDR      R0,[SP, #+12]
   \       0x74   0x....'....        BL       GetPageState
   \       0x78   0x4669             MOV      R1,SP
   \       0x7A   0x7148             STRB     R0,[R1, #+5]
    894          
    895              /* If first page of the group is erasing state, check that all other pages
    896              of the group are also erasing state */
    897              if (firstpagestatus == STATE_PAGE_ERASING)
   \       0x7C   0x4668             MOV      R0,SP
   \       0x7E   0x7940             LDRB     R0,[R0, #+5]
   \       0x80   0x2804             CMP      R0,#+4
   \       0x82   0xD133             BNE      ??EE_CleanUp_IT_2
    898              {
    899                for (page = (firstpage + 1U); page < (firstpage + (PAGES_NUMBER / 2U)); page++)
   \       0x84   0x0027             MOVS     R7,R4
   \       0x86   0x1C7F             ADDS     R7,R7,#+1
   \                     ??EE_CleanUp_IT_3: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x1D40             ADDS     R0,R0,#+5
   \       0x8C   0x4287             CMP      R7,R0
   \       0x8E   0xD221             BCS      ??EE_CleanUp_IT_4
    900                {
    901                  pageaddress = PAGE_ADDRESS(page);
   \       0x90   0x2180             MOVS     R1,#+128
   \       0x92   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x94   0x4379             MULS     R1,R7,R1
   \       0x96   0x9100             STR      R1,[SP, #+0]
   \       0x98   0x20D8             MOVS     R0,#+216
   \       0x9A   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x9C   0x6829             LDR      R1,[R5, #+0]
   \       0x9E   0x0289             LSLS     R1,R1,#+10
   \       0xA0   0x4031             ANDS     R1,R1,R6
   \       0xA2   0x....'....        BL       __aeabi_uidiv
   \       0xA6   0x6829             LDR      R1,[R5, #+0]
   \       0xA8   0x0289             LSLS     R1,R1,#+10
   \       0xAA   0x4031             ANDS     R1,R1,R6
   \       0xAC   0x4348             MULS     R0,R1,R0
   \       0xAE   0x9900             LDR      R1,[SP, #+0]
   \       0xB0   0x1808             ADDS     R0,R1,R0
   \       0xB2   0x2180             MOVS     R1,#+128
   \       0xB4   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0xB6   0x1840             ADDS     R0,R0,R1
   \       0xB8   0x9002             STR      R0,[SP, #+8]
    902                  pagestatus = GetPageState(pageaddress);
   \       0xBA   0x9802             LDR      R0,[SP, #+8]
   \       0xBC   0x....'....        BL       GetPageState
   \       0xC0   0x4669             MOV      R1,SP
   \       0xC2   0x7108             STRB     R0,[R1, #+4]
    903          
    904                  /* If page is not erasing, return error */
    905                  if (pagestatus != STATE_PAGE_ERASING)
   \       0xC4   0x4668             MOV      R0,SP
   \       0xC6   0x7900             LDRB     R0,[R0, #+4]
   \       0xC8   0x2804             CMP      R0,#+4
   \       0xCA   0xD001             BEQ      ??EE_CleanUp_IT_5
    906                  {
    907                    return EE_ERROR_NOERASING_PAGE;
   \       0xCC   0x2005             MOVS     R0,#+5
   \       0xCE   0xE010             B        ??EE_CleanUp_IT_6
    908                  }
    909                }
   \                     ??EE_CleanUp_IT_5: (+1)
   \       0xD0   0x1C7F             ADDS     R7,R7,#+1
   \       0xD2   0xE7D9             B        ??EE_CleanUp_IT_3
    910          
    911                #ifdef DUALCORE_FLASH_SHARING
    912                /* Inform CPU2 about Erase Activity */
    913                SHCI_C2_FLASH_EraseActivity(ERASE_ACTIVITY_ON);
    914                #endif
    915                
    916                /* Erase all the pages of the group */
    917                /* If erase operation fails, a Flash error code is returned */
    918                if (FI_PageErase_IT(firstpage, PAGES_NUMBER / 2U) != EE_OK)
   \                     ??EE_CleanUp_IT_4: (+1)
   \       0xD4   0x2105             MOVS     R1,#+5
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x....'....        BL       FI_PageErase_IT
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD001             BEQ      ??EE_CleanUp_IT_7
    919                {
    920                  return EE_ERASE_ERROR;
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0xE006             B        ??EE_CleanUp_IT_6
    921                }
    922                else
    923                {
    924                  /* To keep their coherency, flush the caches if needed depending on the product */
    925                  FI_CacheFlush();
   \                     ??EE_CleanUp_IT_7: (+1)
   \       0xE4   0x....'....        BL       FI_CacheFlush
    926                  return EE_OK;
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0xE002             B        ??EE_CleanUp_IT_6
    927                }
    928              }
    929            }
   \                     ??EE_CleanUp_IT_2: (+1)
   \       0xEC   0x1D64             ADDS     R4,R4,#+5
   \       0xEE   0xE79F             B        ??EE_CleanUp_IT_0
    930          
    931            /* Error if no erasing pages group is found */
    932            return EE_ERROR_NOERASING_PAGE;
   \                     ??EE_CleanUp_IT_1: (+1)
   \       0xF0   0x2005             MOVS     R0,#+5
   \                     ??EE_CleanUp_IT_6: (+1)
   \       0xF2   0xB005             ADD      SP,SP,#+20
   \       0xF4   0xBDF0             POP      {R4-R7,PC}       ;; return
    933          }
    934          
    935          /**
    936            * @brief  Delete corrupted Flash address, can be called under NMI.
    937            * @param  Address Address of the FLASH Memory to delete
    938            * @retval EE_Status
    939            *           - EE_OK: on success
    940            *           - EE error code: if an error occurs
    941            */

   \                                 In section .text, align 2, keep-with-next
    942          EE_Status EE_DeleteCorruptedFlashAddress(uint32_t Address)
    943          {
   \                     EE_DeleteCorruptedFlashAddress: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    944            return FI_DeleteCorruptedFlashAddress(Address);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x....'....        BL       FI_DeleteCorruptedFlashAddress
   \        0xA   0xBD10             POP      {R4,PC}          ;; return
    945          }
    946          
    947          /**
    948            * @brief  Clean Up end of operation interrupt callback.
    949            * @retval None
    950            */

   \                                 In section .text, align 2
    951          __weak void EE_EndOfCleanup_UserCallback(void)
    952          {
    953            /* NOTE : This function should not be modified, when the callback is needed,
    954                      the EE_EndOfCleanup_UserCallback could be implemented in the user file
    955             */
    956          }
   \                     EE_EndOfCleanup_UserCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    957          
    958          /**
    959            * @}
    960            */
    961          
    962          /* Private functions ---------------------------------------------------------*/
    963          /** @addtogroup EEPROM_Private_Functions
    964            * @{
    965            */
    966          
    967          /**
    968            * @brief  Returns the last stored variable data, if found, which correspond to
    969            *         the passed virtual address
    970            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
    971            * @param  pData Variable containing the EE_DATA_TYPE read variable value
    972            * @retval EE_Status
    973            *           - EE_OK: if variable was found
    974            *           - EE error code: if an error occurs
    975            */

   \                                 In section .text, align 2, keep-with-next
    976          static EE_Status ReadVariable(uint16_t VirtAddress, EE_DATA_TYPE* pData)
    977          {
   \                     ReadVariable: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    978            EE_ELEMENT_TYPE addressvalue = 0U;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2500             MOVS     R5,#+0
    979            uint32_t page = 0U, pageaddress = 0U, counter = 0U, crc = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0x0006             MOVS     R6,R0
   \       0x10   0x9003             STR      R0,[SP, #+12]
    980            EE_State_type pagestate = STATE_PAGE_INVALID;
   \       0x12   0x2005             MOVS     R0,#+5
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x7108             STRB     R0,[R1, #+4]
    981          
    982            /* Get active Page for read operation */
    983            page = FindPage(FIND_READ_PAGE);
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x....'....        BL       FindPage
   \       0x1E   0x0007             MOVS     R7,R0
    984          
    985            /* Check if there is no active page */
    986            if (page == EE_NO_PAGE_FOUND)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x24   0x4287             CMP      R7,R0
   \       0x26   0xD101             BNE      ??ReadVariable_0
    987            {
    988              return EE_ERROR_NOACTIVE_PAGE;
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0xE095             B        ??ReadVariable_1
    989            }
    990            pageaddress = PAGE_ADDRESS(page);
   \                     ??ReadVariable_0: (+1)
   \       0x2C   0x2080             MOVS     R0,#+128
   \       0x2E   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \       0x30   0x4378             MULS     R0,R7,R0
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x20D8             MOVS     R0,#+216
   \       0x36   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x38   0x....             LDR      R1,??DataTable13  ;; 0x1fff75e0
   \       0x3A   0x6809             LDR      R1,[R1, #+0]
   \       0x3C   0x028A             LSLS     R2,R1,#+10
   \       0x3E   0x21FF             MOVS     R1,#+255
   \       0x40   0x0289             LSLS     R1,R1,#+10       ;; #+261120
   \       0x42   0x4011             ANDS     R1,R1,R2
   \       0x44   0x....'....        BL       __aeabi_uidiv
   \       0x48   0x0001             MOVS     R1,R0
   \       0x4A   0x....             LDR      R0,??DataTable13  ;; 0x1fff75e0
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x0280             LSLS     R0,R0,#+10
   \       0x50   0x22FF             MOVS     R2,#+255
   \       0x52   0x0292             LSLS     R2,R2,#+10       ;; #+261120
   \       0x54   0x4002             ANDS     R2,R2,R0
   \       0x56   0x4351             MULS     R1,R2,R1
   \       0x58   0x9800             LDR      R0,[SP, #+0]
   \       0x5A   0x1840             ADDS     R0,R0,R1
   \       0x5C   0x2180             MOVS     R1,#+128
   \       0x5E   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x60   0x1840             ADDS     R0,R0,R1
   \       0x62   0x9002             STR      R0,[SP, #+8]
    991            pagestate = GetPageState(pageaddress);
   \       0x64   0x9802             LDR      R0,[SP, #+8]
   \       0x66   0x....'....        BL       GetPageState
   \       0x6A   0x4669             MOV      R1,SP
   \       0x6C   0x7108             STRB     R0,[R1, #+4]
    992          
    993            /* Search variable in active page and valid pages until erased page is found
    994               or in erasing pages until erased page is found */
    995            while ((pagestate == STATE_PAGE_ACTIVE) || (pagestate == STATE_PAGE_VALID) || (pagestate == STATE_PAGE_ERASING))
   \                     ??ReadVariable_2: (+1)
   \       0x6E   0x4668             MOV      R0,SP
   \       0x70   0x7900             LDRB     R0,[R0, #+4]
   \       0x72   0x2802             CMP      R0,#+2
   \       0x74   0xD007             BEQ      ??ReadVariable_3
   \       0x76   0x4668             MOV      R0,SP
   \       0x78   0x7900             LDRB     R0,[R0, #+4]
   \       0x7A   0x2803             CMP      R0,#+3
   \       0x7C   0xD003             BEQ      ??ReadVariable_3
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0x7900             LDRB     R0,[R0, #+4]
   \       0x82   0x2804             CMP      R0,#+4
   \       0x84   0xD167             BNE      ??ReadVariable_4
    996            {
    997              /* Set counter index to last element position in the page */
    998              counter = PAGE_SIZE - EE_ELEMENT_SIZE;
   \                     ??ReadVariable_3: (+1)
   \       0x86   0x20FF             MOVS     R0,#+255
   \       0x88   0x00C0             LSLS     R0,R0,#+3        ;; #+2040
   \       0x8A   0x0006             MOVS     R6,R0
    999          
   1000              /* Check each page address starting from end */
   1001              while (counter >= PAGE_HEADER_SIZE)
   \                     ??ReadVariable_5: (+1)
   \       0x8C   0x2E20             CMP      R6,#+32
   \       0x8E   0xD322             BCC      ??ReadVariable_6
   1002              {
   1003                /* Get the current location content to be compared with virtual address */
   1004                addressvalue = (*(__IO EE_ELEMENT_TYPE*)(pageaddress + counter));
   \       0x90   0x9802             LDR      R0,[SP, #+8]
   \       0x92   0x1980             ADDS     R0,R0,R6
   \       0x94   0xC803             LDM      R0,{R0,R1}
   \       0x96   0x0004             MOVS     R4,R0
   \       0x98   0x000D             MOVS     R5,R1
   1005                if (addressvalue != EE_PAGESTAT_ERASED)
   \       0x9A   0x....             ADR      R0,??DataTable14
   \       0x9C   0xC803             LDM      R0,{R0,R1}
   \       0x9E   0x428D             CMP      R5,R1
   \       0xA0   0xD101             BNE      ??ReadVariable_7
   \       0xA2   0x4284             CMP      R4,R0
   \       0xA4   0xD015             BEQ      ??ReadVariable_8
   1006                {
   1007                  /* Compare the read address with the virtual address */
   1008                  if (EE_VIRTUALADDRESS_VALUE(addressvalue) == VirtAddress)
   \                     ??ReadVariable_7: (+1)
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x8A89             LDRH     R1,[R1, #+20]
   \       0xAC   0xB280             UXTH     R0,R0
   \       0xAE   0x4288             CMP      R0,R1
   \       0xB0   0xD10F             BNE      ??ReadVariable_8
   1009                  {
   1010                    /* Calculate crc of variable data and virtual address */
   1011                    crc = CalculateCrc(EE_DATA_VALUE(addressvalue), EE_VIRTUALADDRESS_VALUE(addressvalue));
   \       0xB2   0x0021             MOVS     R1,R4
   \       0xB4   0xB289             UXTH     R1,R1
   \       0xB6   0x0028             MOVS     R0,R5
   \       0xB8   0x....'....        BL       CalculateCrc
   \       0xBC   0x9003             STR      R0,[SP, #+12]
   1012          
   1013                    /* if crc verification pass, data is correct and is returned.
   1014                       if crc verification fails, data is corrupted and has to be skip */
   1015                    if (crc == EE_CRC_VALUE(addressvalue))
   \       0xBE   0x9803             LDR      R0,[SP, #+12]
   \       0xC0   0x0021             MOVS     R1,R4
   \       0xC2   0x0C09             LSRS     R1,R1,#+16
   \       0xC4   0xB289             UXTH     R1,R1
   \       0xC6   0x4288             CMP      R0,R1
   \       0xC8   0xD103             BNE      ??ReadVariable_8
   1016                    {
   1017                      /* Get content of variable value */
   1018                      *pData = EE_DATA_VALUE(addressvalue);
   \       0xCA   0x9806             LDR      R0,[SP, #+24]
   \       0xCC   0x6005             STR      R5,[R0, #+0]
   1019          
   1020                      return EE_OK;
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0xE042             B        ??ReadVariable_1
   1021                    }
   1022                  }
   1023                }
   1024                /* Next address location */
   1025                counter -= EE_ELEMENT_SIZE;
   \                     ??ReadVariable_8: (+1)
   \       0xD2   0x3E08             SUBS     R6,R6,#+8
   \       0xD4   0xE7DA             B        ??ReadVariable_5
   1026              }
   1027          
   1028              /* Decrement page index circularly, among pages allocated to eeprom emulation */
   1029              page = PREVIOUS_PAGE(page);
   \                     ??ReadVariable_6: (+1)
   \       0xD6   0x20D8             MOVS     R0,#+216
   \       0xD8   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0xDA   0x....             LDR      R1,??DataTable13  ;; 0x1fff75e0
   \       0xDC   0x6809             LDR      R1,[R1, #+0]
   \       0xDE   0x028A             LSLS     R2,R1,#+10
   \       0xE0   0x21FF             MOVS     R1,#+255
   \       0xE2   0x0289             LSLS     R1,R1,#+10       ;; #+261120
   \       0xE4   0x4011             ANDS     R1,R1,R2
   \       0xE6   0x....'....        BL       __aeabi_uidivmod
   \       0xEA   0x0AC8             LSRS     R0,R1,#+11
   \       0xEC   0x1A38             SUBS     R0,R7,R0
   \       0xEE   0x3009             ADDS     R0,R0,#+9
   \       0xF0   0x210A             MOVS     R1,#+10
   \       0xF2   0x....'....        BL       __aeabi_uidivmod
   \       0xF6   0x000F             MOVS     R7,R1
   \       0xF8   0x20D8             MOVS     R0,#+216
   \       0xFA   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0xFC   0x....             LDR      R1,??DataTable13  ;; 0x1fff75e0
   \       0xFE   0x6809             LDR      R1,[R1, #+0]
   \      0x100   0x028A             LSLS     R2,R1,#+10
   \      0x102   0x21FF             MOVS     R1,#+255
   \      0x104   0x0289             LSLS     R1,R1,#+10       ;; #+261120
   \      0x106   0x4011             ANDS     R1,R1,R2
   \      0x108   0x....'....        BL       __aeabi_uidivmod
   \      0x10C   0x0AC8             LSRS     R0,R1,#+11
   \      0x10E   0x0039             MOVS     R1,R7
   \      0x110   0x180F             ADDS     R7,R1,R0
   1030              pageaddress = PAGE_ADDRESS(page);
   \      0x112   0x2080             MOVS     R0,#+128
   \      0x114   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x116   0x4378             MULS     R0,R7,R0
   \      0x118   0x9000             STR      R0,[SP, #+0]
   \      0x11A   0x20D8             MOVS     R0,#+216
   \      0x11C   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \      0x11E   0x....             LDR      R1,??DataTable13  ;; 0x1fff75e0
   \      0x120   0x6809             LDR      R1,[R1, #+0]
   \      0x122   0x028A             LSLS     R2,R1,#+10
   \      0x124   0x21FF             MOVS     R1,#+255
   \      0x126   0x0289             LSLS     R1,R1,#+10       ;; #+261120
   \      0x128   0x4011             ANDS     R1,R1,R2
   \      0x12A   0x....'....        BL       __aeabi_uidiv
   \      0x12E   0x0001             MOVS     R1,R0
   \      0x130   0x....             LDR      R0,??DataTable13  ;; 0x1fff75e0
   \      0x132   0x6800             LDR      R0,[R0, #+0]
   \      0x134   0x0280             LSLS     R0,R0,#+10
   \      0x136   0x22FF             MOVS     R2,#+255
   \      0x138   0x0292             LSLS     R2,R2,#+10       ;; #+261120
   \      0x13A   0x4002             ANDS     R2,R2,R0
   \      0x13C   0x4351             MULS     R1,R2,R1
   \      0x13E   0x9800             LDR      R0,[SP, #+0]
   \      0x140   0x1840             ADDS     R0,R0,R1
   \      0x142   0x2180             MOVS     R1,#+128
   \      0x144   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x146   0x1840             ADDS     R0,R0,R1
   \      0x148   0x9002             STR      R0,[SP, #+8]
   1031              pagestate = GetPageState(pageaddress);
   \      0x14A   0x9802             LDR      R0,[SP, #+8]
   \      0x14C   0x....'....        BL       GetPageState
   \      0x150   0x4669             MOV      R1,SP
   \      0x152   0x7108             STRB     R0,[R1, #+4]
   \      0x154   0xE78B             B        ??ReadVariable_2
   1032            }
   1033          
   1034            /* Variable is not found */
   1035            return EE_NO_DATA;
   \                     ??ReadVariable_4: (+1)
   \      0x156   0x2007             MOVS     R0,#+7
   \                     ??ReadVariable_1: (+1)
   \      0x158   0xB007             ADD      SP,SP,#+28
   \      0x15A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1036          }
   1037          
   1038          /**
   1039            * @brief  Writes/updates variable data in EEPROM
   1040            *         Trig internal Pages transfer if half of the pages are full
   1041            * @param VirtAddress Variable virtual address on 16 bits (can't be 0x0000 or 0xFFFF)
   1042            * @param  Data EE_DATA_TYPE data to be written
   1043            * @retval EE_Status
   1044            *           - EE_OK: on success, without page transfer
   1045            *           - EE_CLEANUP_REQUIRED: on success, with page transfer occured
   1046            *           - EE_FLASH_USED: flash currently used by CPU2
   1047            *           - EE error code: if an error occurs
   1048            */

   \                                 In section .text, align 2, keep-with-next
   1049          static EE_Status WriteVariable(uint16_t VirtAddress, EE_DATA_TYPE Data)
   1050          {
   \                     WriteVariable: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
   1051            EE_Status status = EE_OK;
   \        0x6   0x2700             MOVS     R7,#+0
   1052          
   1053            /* Write the variable virtual address and value in the EEPROM, if not full */
   1054            #ifdef DUALCORE_FLASH_SHARING
   1055            status = VerifyPagesFullWriteVariable(VirtAddress, Data, EE_SIMPLE_WRITE);
   1056            #else
   1057            status = VerifyPagesFullWriteVariable(VirtAddress, Data);
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x....'....        BL       VerifyPagesFullWriteVariable
   \       0x12   0x0004             MOVS     R4,R0
   1058            #endif
   1059            if (status == EE_PAGE_FULL)
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB200             SXTH     R0,R0
   \       0x18   0x2812             CMP      R0,#+18
   \       0x1A   0xD106             BNE      ??WriteVariable_0
   1060            {
   1061              /* In case the EEPROM pages are full, perform Pages transfer */
   1062              return PagesTransfer(VirtAddress, Data, EE_TRANSFER_NORMAL);
   \       0x1C   0x2200             MOVS     R2,#+0
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x....'....        BL       PagesTransfer
   \       0x28   0xE001             B        ??WriteVariable_1
   1063            }
   1064          
   1065            /* Return last operation status */
   1066            return status;
   \                     ??WriteVariable_0: (+1)
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0xB200             SXTH     R0,R0
   \                     ??WriteVariable_1: (+1)
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1067          }
   1068          
   1069          /**
   1070            * @brief  Verify if specified page is fully erased.
   1071            * @param  Address page address
   1072            * @param  PageSize page size
   1073            * @retval EE_Status
   1074            *           - EE_PAGE_NOTERASED : if Page not erased
   1075            *           - EE_PAGE_ERASED    : if Page erased
   1076            */

   \                                 In section .text, align 2, keep-with-next
   1077          static EE_Status VerifyPageFullyErased(uint32_t Address, uint32_t PageSize)
   1078          {
   \                     VerifyPageFullyErased: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0003             MOVS     R3,R0
   \        0x4   0x000A             MOVS     R2,R1
   1079            EE_Status readstatus = EE_PAGE_ERASED;
   \        0x6   0x2711             MOVS     R7,#+17
   1080            uint32_t counter = 0U;
   \        0x8   0x2600             MOVS     R6,#+0
   1081          
   1082            /* Check each element in the page */
   1083            while (counter < PageSize)
   \                     ??VerifyPageFullyErased_0: (+1)
   \        0xA   0x4296             CMP      R6,R2
   \        0xC   0xD20B             BCS      ??VerifyPageFullyErased_1
   1084            {
   1085              /* Compare the read address with the virtual address */
   1086              if ((*(__IO EE_ELEMENT_TYPE*)(Address+counter)) != EE_PAGESTAT_ERASED)
   \        0xE   0x1998             ADDS     R0,R3,R6
   \       0x10   0xC803             LDM      R0,{R0,R1}
   \       0x12   0x....             ADR      R4,??DataTable14
   \       0x14   0xCC30             LDM      R4,{R4,R5}
   \       0x16   0x42A9             CMP      R1,R5
   \       0x18   0xD101             BNE      ??VerifyPageFullyErased_2
   \       0x1A   0x42A0             CMP      R0,R4
   \       0x1C   0xD001             BEQ      ??VerifyPageFullyErased_3
   1087              {
   1088                /* In case one element is not erased, reset readstatus flag */
   1089                readstatus = EE_PAGE_NOTERASED;
   \                     ??VerifyPageFullyErased_2: (+1)
   \       0x1E   0x2010             MOVS     R0,#+16
   \       0x20   0x0007             MOVS     R7,R0
   1090              }
   1091              /* Next address location */
   1092              counter = counter + EE_ELEMENT_SIZE;
   \                     ??VerifyPageFullyErased_3: (+1)
   \       0x22   0x3608             ADDS     R6,R6,#+8
   \       0x24   0xE7F1             B        ??VerifyPageFullyErased_0
   1093            }
   1094          
   1095            /* Return readstatus value */
   1096            return readstatus;
   \                     ??VerifyPageFullyErased_1: (+1)
   \       0x26   0x0038             MOVS     R0,R7
   \       0x28   0xB200             SXTH     R0,R0
   \       0x2A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1097          }
   1098          
   1099          /**
   1100            * @brief  Find suitable page for read/write/erase operation.
   1101            *   It also update pages state if current page is full.
   1102            *   And it force cleanup if all pages are full.
   1103            * @param  Operation Type of page to be requested.
   1104            *   This parameter can be one of the following values:
   1105            *     @arg @ref FIND_READ_PAGE return the active page index
   1106            *     @arg @ref FIND_WRITE_PAGE return the write page index
   1107            *     @arg @ref FIND_ERASE_PAGE return the erase page index
   1108            * @retval Page_Index
   1109            *           - Page Index: on success
   1110            *           - @ref EE_NO_PAGE_FOUND : if an error occurs
   1111            */

   \                                 In section .text, align 2, keep-with-next
   1112          static uint32_t FindPage(EE_Find_type Operation)
   1113          {
   \                     FindPage: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   1114            EE_State_type currentpagestatus = STATE_PAGE_INVALID, followingpagestatus = STATE_PAGE_INVALID;
   \        0x4   0x2005             MOVS     R0,#+5
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7108             STRB     R0,[R1, #+4]
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x7148             STRB     R0,[R1, #+5]
   1115            uint32_t currentpage = 0U, followingpage = 0U, previouspage = 0U;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9003             STR      R0,[SP, #+12]
   \       0x12   0x9000             STR      R0,[SP, #+0]
   \       0x14   0x9002             STR      R0,[SP, #+8]
   1116          
   1117            /* Get currentpage status */
   1118            currentpage = ubCurrentActivePage;
   \       0x16   0x....             LDR      R0,??DataTable14_1
   \       0x18   0x7806             LDRB     R6,[R0, #+0]
   1119            currentpagestatus = GetPageState(PAGE_ADDRESS(currentpage));
   \       0x1A   0x25FF             MOVS     R5,#+255
   \       0x1C   0x02AD             LSLS     R5,R5,#+10       ;; #+261120
   \       0x1E   0x....             LDR      R4,??DataTable14_2  ;; 0x1fff75e0
   \       0x20   0x2780             MOVS     R7,#+128
   \       0x22   0x013F             LSLS     R7,R7,#+4        ;; #+2048
   \       0x24   0x4377             MULS     R7,R6,R7
   \       0x26   0x20D8             MOVS     R0,#+216
   \       0x28   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x0289             LSLS     R1,R1,#+10
   \       0x2E   0x4029             ANDS     R1,R1,R5
   \       0x30   0x....'....        BL       __aeabi_uidiv
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x0289             LSLS     R1,R1,#+10
   \       0x38   0x4029             ANDS     R1,R1,R5
   \       0x3A   0x4348             MULS     R0,R1,R0
   \       0x3C   0x1838             ADDS     R0,R7,R0
   \       0x3E   0x2180             MOVS     R1,#+128
   \       0x40   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x42   0x1840             ADDS     R0,R0,R1
   \       0x44   0x....'....        BL       GetPageState
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x7108             STRB     R0,[R1, #+4]
   1120          
   1121            /* Get followingpage status */
   1122            followingpage = FOLLOWING_PAGE(currentpage);
   \       0x4C   0x20D8             MOVS     R0,#+216
   \       0x4E   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x0289             LSLS     R1,R1,#+10
   \       0x54   0x4029             ANDS     R1,R1,R5
   \       0x56   0x....'....        BL       __aeabi_uidivmod
   \       0x5A   0x0AC8             LSRS     R0,R1,#+11
   \       0x5C   0x1A30             SUBS     R0,R6,R0
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0x210A             MOVS     R1,#+10
   \       0x62   0x....'....        BL       __aeabi_uidivmod
   \       0x66   0x000F             MOVS     R7,R1
   \       0x68   0x20D8             MOVS     R0,#+216
   \       0x6A   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x6C   0x6821             LDR      R1,[R4, #+0]
   \       0x6E   0x0289             LSLS     R1,R1,#+10
   \       0x70   0x4029             ANDS     R1,R1,R5
   \       0x72   0x....'....        BL       __aeabi_uidivmod
   \       0x76   0x0AC8             LSRS     R0,R1,#+11
   \       0x78   0x0039             MOVS     R1,R7
   \       0x7A   0x180F             ADDS     R7,R1,R0
   1123            followingpagestatus = GetPageState(PAGE_ADDRESS(followingpage));
   \       0x7C   0x2180             MOVS     R1,#+128
   \       0x7E   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x80   0x4379             MULS     R1,R7,R1
   \       0x82   0x9100             STR      R1,[SP, #+0]
   \       0x84   0x20D8             MOVS     R0,#+216
   \       0x86   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x88   0x6821             LDR      R1,[R4, #+0]
   \       0x8A   0x0289             LSLS     R1,R1,#+10
   \       0x8C   0x4029             ANDS     R1,R1,R5
   \       0x8E   0x....'....        BL       __aeabi_uidiv
   \       0x92   0x6821             LDR      R1,[R4, #+0]
   \       0x94   0x0289             LSLS     R1,R1,#+10
   \       0x96   0x4029             ANDS     R1,R1,R5
   \       0x98   0x4348             MULS     R0,R1,R0
   \       0x9A   0x9900             LDR      R1,[SP, #+0]
   \       0x9C   0x1808             ADDS     R0,R1,R0
   \       0x9E   0x2180             MOVS     R1,#+128
   \       0xA0   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0xA2   0x1840             ADDS     R0,R0,R1
   \       0xA4   0x....'....        BL       GetPageState
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x7148             STRB     R0,[R1, #+5]
   1124          
   1125            /* Get previouspage status */
   1126            previouspage = PREVIOUS_PAGE(currentpage);
   \       0xAC   0x20D8             MOVS     R0,#+216
   \       0xAE   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0xB0   0x6821             LDR      R1,[R4, #+0]
   \       0xB2   0x0289             LSLS     R1,R1,#+10
   \       0xB4   0x4029             ANDS     R1,R1,R5
   \       0xB6   0x....'....        BL       __aeabi_uidivmod
   \       0xBA   0x0AC8             LSRS     R0,R1,#+11
   \       0xBC   0x1A30             SUBS     R0,R6,R0
   \       0xBE   0x3009             ADDS     R0,R0,#+9
   \       0xC0   0x210A             MOVS     R1,#+10
   \       0xC2   0x....'....        BL       __aeabi_uidivmod
   \       0xC6   0x9100             STR      R1,[SP, #+0]
   \       0xC8   0x20D8             MOVS     R0,#+216
   \       0xCA   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0xCC   0x6821             LDR      R1,[R4, #+0]
   \       0xCE   0x0289             LSLS     R1,R1,#+10
   \       0xD0   0x400D             ANDS     R5,R5,R1
   \       0xD2   0x0029             MOVS     R1,R5
   \       0xD4   0x....'....        BL       __aeabi_uidivmod
   \       0xD8   0x0AC8             LSRS     R0,R1,#+11
   \       0xDA   0x9900             LDR      R1,[SP, #+0]
   \       0xDC   0x180D             ADDS     R5,R1,R0
   1127          
   1128            /* Write, read or erase operation */
   1129            switch (Operation)
   \       0xDE   0x4668             MOV      R0,SP
   \       0xE0   0x7C00             LDRB     R0,[R0, #+16]
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD05F             BEQ      ??FindPage_0
   \       0xE6   0x2802             CMP      R0,#+2
   \       0xE8   0xD06C             BEQ      ??FindPage_1
   \       0xEA   0xD274             BCS      ??FindPage_2
   1130            {
   1131              case FIND_WRITE_PAGE:   /* ---- Write operation ---- */
   1132                /* Normal operation, no page transfer on going */
   1133                if (currentpagestatus == STATE_PAGE_ACTIVE)
   \                     ??FindPage_3: (+1)
   \       0xEC   0x4668             MOV      R0,SP
   \       0xEE   0x7900             LDRB     R0,[R0, #+4]
   \       0xF0   0x2802             CMP      R0,#+2
   \       0xF2   0xD128             BNE      ??FindPage_4
   1134                {
   1135                  /* Check if active page is not full */
   1136                  if (uwAddressNextWrite < PAGE_SIZE)
   \       0xF4   0x....             LDR      R4,??DataTable14_3
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x2180             MOVS     R1,#+128
   \       0xFA   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xFC   0x4288             CMP      R0,R1
   \       0xFE   0xD201             BCS      ??FindPage_5
   1137                  {
   1138                    /* Return current Active page */
   1139                    return currentpage;
   \      0x100   0x0030             MOVS     R0,R6
   \      0x102   0xE06A             B        ??FindPage_6
   1140                  }
   1141                  else
   1142                  /* No more space in current active page */
   1143                  {
   1144                    /* Check if following page is erasing state */
   1145                    if (followingpagestatus == STATE_PAGE_ERASING)
   \                     ??FindPage_5: (+1)
   \      0x104   0x4668             MOV      R0,SP
   \      0x106   0x7940             LDRB     R0,[R0, #+5]
   \      0x108   0x2804             CMP      R0,#+4
   \      0x10A   0xD106             BNE      ??FindPage_7
   1146                    {
   1147                      /* Force Cleanup, as not yet performed by user */
   1148                      if (EE_CleanUp() != EE_OK)
   \      0x10C   0x....'....        BL       EE_CleanUp
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD002             BEQ      ??FindPage_7
   1149                      {
   1150                        return EE_NO_PAGE_FOUND;
   \      0x114   0x2000             MOVS     R0,#+0
   \      0x116   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x118   0xE05F             B        ??FindPage_6
   1151                      }
   1152                    }
   1153          
   1154                    /* Set current active page in valid state */
   1155                    if (SetPageState(currentpage, STATE_PAGE_VALID) != EE_OK)
   \                     ??FindPage_7: (+1)
   \      0x11A   0x2103             MOVS     R1,#+3
   \      0x11C   0x0030             MOVS     R0,R6
   \      0x11E   0x....'....        BL       SetPageState
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD002             BEQ      ??FindPage_8
   1156                    {
   1157                      return EE_NO_PAGE_FOUND;
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x12A   0xE056             B        ??FindPage_6
   1158                    }
   1159          
   1160                    /* Set following page as active */
   1161                    if (SetPageState(followingpage, STATE_PAGE_ACTIVE) != EE_OK)
   \                     ??FindPage_8: (+1)
   \      0x12C   0x2102             MOVS     R1,#+2
   \      0x12E   0x0038             MOVS     R0,R7
   \      0x130   0x....'....        BL       SetPageState
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD002             BEQ      ??FindPage_9
   1162                    {
   1163                      return EE_NO_PAGE_FOUND;
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x13C   0xE04D             B        ??FindPage_6
   1164                    }
   1165                    uwAddressNextWrite = PAGE_HEADER_SIZE;   /* Skip page header */
   \                     ??FindPage_9: (+1)
   \      0x13E   0x2020             MOVS     R0,#+32
   \      0x140   0x6020             STR      R0,[R4, #+0]
   1166                    return followingpage;         /* Following page is now active one */
   \      0x142   0x0038             MOVS     R0,R7
   \      0x144   0xE049             B        ??FindPage_6
   1167                  }
   1168                }
   1169                /* Transfer is on going, page receiving data */
   1170                else
   1171                {
   1172                  if (currentpagestatus == STATE_PAGE_RECEIVE)
   \                     ??FindPage_4: (+1)
   \      0x146   0x4668             MOV      R0,SP
   \      0x148   0x7900             LDRB     R0,[R0, #+4]
   \      0x14A   0x2801             CMP      R0,#+1
   \      0x14C   0xD128             BNE      ??FindPage_10
   1173                  {
   1174                    /* Check if receive page is not full */
   1175                    if (uwAddressNextWrite < PAGE_SIZE)
   \      0x14E   0x....             LDR      R4,??DataTable14_3
   \      0x150   0x6820             LDR      R0,[R4, #+0]
   \      0x152   0x2180             MOVS     R1,#+128
   \      0x154   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x156   0x4288             CMP      R0,R1
   \      0x158   0xD201             BCS      ??FindPage_11
   1176                    {
   1177                      /* Return current receive page */
   1178                      return currentpage;
   \      0x15A   0x0030             MOVS     R0,R6
   \      0x15C   0xE03D             B        ??FindPage_6
   1179                    }
   1180                    else
   1181                    /* No more space in current receive page */
   1182                    {
   1183                      /* Check if following page is erasing state */
   1184                      if (followingpagestatus == STATE_PAGE_ERASING)
   \                     ??FindPage_11: (+1)
   \      0x15E   0x4668             MOV      R0,SP
   \      0x160   0x7940             LDRB     R0,[R0, #+5]
   \      0x162   0x2804             CMP      R0,#+4
   \      0x164   0xD106             BNE      ??FindPage_12
   1185                      {
   1186                        /* Force Cleanup, as not yet performed by user */
   1187                        if (EE_CleanUp() != EE_OK)
   \      0x166   0x....'....        BL       EE_CleanUp
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD002             BEQ      ??FindPage_12
   1188                        {
   1189                          return EE_NO_PAGE_FOUND;
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x172   0xE032             B        ??FindPage_6
   1190                        }
   1191                      }
   1192          
   1193                      /* Set current receive page in valid state */
   1194                      if (SetPageState(currentpage, STATE_PAGE_VALID) != EE_OK)
   \                     ??FindPage_12: (+1)
   \      0x174   0x2103             MOVS     R1,#+3
   \      0x176   0x0030             MOVS     R0,R6
   \      0x178   0x....'....        BL       SetPageState
   \      0x17C   0x2800             CMP      R0,#+0
   \      0x17E   0xD002             BEQ      ??FindPage_13
   1195                      {
   1196                        return EE_NO_PAGE_FOUND;
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x184   0xE029             B        ??FindPage_6
   1197                      }
   1198          
   1199                      /* Set following page as receive */
   1200                      if (SetPageState(followingpage, STATE_PAGE_RECEIVE) != EE_OK)
   \                     ??FindPage_13: (+1)
   \      0x186   0x2101             MOVS     R1,#+1
   \      0x188   0x0038             MOVS     R0,R7
   \      0x18A   0x....'....        BL       SetPageState
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD002             BEQ      ??FindPage_14
   1201                      {
   1202                        return EE_NO_PAGE_FOUND;
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x196   0xE020             B        ??FindPage_6
   1203                      }
   1204                      uwAddressNextWrite = PAGE_HEADER_SIZE;   /* Skip page header */
   \                     ??FindPage_14: (+1)
   \      0x198   0x2020             MOVS     R0,#+32
   \      0x19A   0x6020             STR      R0,[R4, #+0]
   1205                      return followingpage;         /* Following page is now active one */
   \      0x19C   0x0038             MOVS     R0,R7
   \      0x19E   0xE01C             B        ??FindPage_6
   1206                    }
   1207                  }
   1208                  else
   1209                  {
   1210                    return EE_NO_PAGE_FOUND;   /* No active Page */
   \                     ??FindPage_10: (+1)
   \      0x1A0   0x2000             MOVS     R0,#+0
   \      0x1A2   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x1A4   0xE019             B        ??FindPage_6
   1211                  }
   1212                }
   1213          
   1214              case FIND_READ_PAGE:  /* ---- Read operation ---- */
   1215                if (currentpagestatus == STATE_PAGE_ACTIVE)
   \                     ??FindPage_0: (+1)
   \      0x1A6   0x4668             MOV      R0,SP
   \      0x1A8   0x7900             LDRB     R0,[R0, #+4]
   \      0x1AA   0x2802             CMP      R0,#+2
   \      0x1AC   0xD101             BNE      ??FindPage_15
   1216                {
   1217                  return currentpage;
   \      0x1AE   0x0030             MOVS     R0,R6
   \      0x1B0   0xE013             B        ??FindPage_6
   1218                }
   1219                else
   1220                {
   1221                  if (currentpagestatus == STATE_PAGE_RECEIVE)
   \                     ??FindPage_15: (+1)
   \      0x1B2   0x4668             MOV      R0,SP
   \      0x1B4   0x7900             LDRB     R0,[R0, #+4]
   \      0x1B6   0x2801             CMP      R0,#+1
   \      0x1B8   0xD101             BNE      ??FindPage_16
   1222                  {
   1223                    return previouspage;
   \      0x1BA   0x0028             MOVS     R0,R5
   \      0x1BC   0xE00D             B        ??FindPage_6
   1224                  }
   1225                  else
   1226                  {
   1227                    return EE_NO_PAGE_FOUND;   /* No active Page */
   \                     ??FindPage_16: (+1)
   \      0x1BE   0x2000             MOVS     R0,#+0
   \      0x1C0   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x1C2   0xE00A             B        ??FindPage_6
   1228                  }
   1229                }
   1230          
   1231              case FIND_ERASE_PAGE: /* ---- Return the erased page */
   1232                if (followingpagestatus == STATE_PAGE_ERASED)
   \                     ??FindPage_1: (+1)
   \      0x1C4   0x4668             MOV      R0,SP
   \      0x1C6   0x7940             LDRB     R0,[R0, #+5]
   \      0x1C8   0x2800             CMP      R0,#+0
   \      0x1CA   0xD101             BNE      ??FindPage_17
   1233                {
   1234                  return followingpage;
   \      0x1CC   0x0038             MOVS     R0,R7
   \      0x1CE   0xE004             B        ??FindPage_6
   1235                }
   1236                else
   1237                {
   1238                  return EE_NO_PAGE_FOUND;  /* No erased Page */
   \                     ??FindPage_17: (+1)
   \      0x1D0   0x2000             MOVS     R0,#+0
   \      0x1D2   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x1D4   0xE001             B        ??FindPage_6
   1239                }
   1240          
   1241              default:
   1242                ;
   1243            }
   1244          
   1245            return EE_NO_PAGE_FOUND;
   \                     ??FindPage_2: (+1)
   \      0x1D6   0x2000             MOVS     R0,#+0
   \      0x1D8   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??FindPage_6: (+1)
   \      0x1DA   0xB005             ADD      SP,SP,#+20
   \      0x1DC   0xBDF0             POP      {R4-R7,PC}       ;; return
   1246          }
   1247          
   1248          /**
   1249            * @brief  Writes a new variable data in fresh new page in case of normal
   1250            *         transfer, and transfers last updated elements from full pages to
   1251            *         empty pages in any cases.
   1252            * @param  VirtAddress 16 bit virtual address of the new variable data
   1253            * @param  Data @ref EE_DATA_TYPE data value of the new variable data
   1254            * @param  Type Type of transfer.
   1255            *         This parameter can be one of the EE_Transfer_type enum values.
   1256            *            @arg @ref EE_TRANSFER_NORMAL Pages transfer during normal processing
   1257            *            @arg @ref EE_TRANSFER_RECOVER Recovering pages transfer at Init
   1258            * @retval EE_Status
   1259            *           - EE_CLEANUP_REQUIRED: on success
   1260            *           - EE error code: if an error occurs
   1261            */

   \                                 In section .text, align 2, keep-with-next
   1262          static EE_Status PagesTransfer(uint16_t VirtAddress, EE_DATA_TYPE Data, EE_Transfer_type Type)
   1263          {
   \                     PagesTransfer: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   1264            EE_State_type pagestatus = STATE_PAGE_INVALID;
   \        0x4   0x2705             MOVS     R7,#+5
   1265            uint32_t pageaddress = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9002             STR      R0,[SP, #+8]
   1266            uint32_t page = 0U;
   \        0xA   0x2500             MOVS     R5,#+0
   1267            uint32_t varidx = 0U;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9003             STR      R0,[SP, #+12]
   1268            EE_ELEMENT_TYPE addressvalue = 0U;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0xAA06             ADD      R2,SP,#+24
   \       0x16   0xC203             STM      R2!,{R0,R1}
   \       0x18   0x3A08             SUBS     R2,R2,#+8
   1269            EE_Status status = EE_OK;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x80C8             STRH     R0,[R1, #+6]
   1270            EE_DATA_TYPE DataValue = 0U;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x9004             STR      R0,[SP, #+16]
   1271          
   1272            /* Get receive Page for transfer operation */
   1273            page = FindPage((Type == EE_TRANSFER_NORMAL?FIND_ERASE_PAGE:FIND_WRITE_PAGE));
   \       0x24   0xA80A             ADD      R0,SP,#+40
   \       0x26   0x7800             LDRB     R0,[R0, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD101             BNE      ??PagesTransfer_0
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xE000             B        ??PagesTransfer_1
   \                     ??PagesTransfer_0: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \                     ??PagesTransfer_1: (+1)
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x....'....        BL       FindPage
   \       0x38   0x0004             MOVS     R4,R0
   1274            if (page == EE_NO_PAGE_FOUND)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x3E   0x4284             CMP      R4,R0
   \       0x40   0xD101             BNE      ??PagesTransfer_2
   1275            {
   1276              return EE_ERROR_NOERASE_PAGE;
   \       0x42   0x2004             MOVS     R0,#+4
   \       0x44   0xE19C             B        ??PagesTransfer_3
   1277            }
   1278          
   1279            /* Reinitialize number of data written in the pages, and current active page */
   1280            uhNbWrittenElements = 0U;
   \                     ??PagesTransfer_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x....             LDR      R1,??DataTable15
   \       0x4A   0x8008             STRH     R0,[R1, #+0]
   1281            ubCurrentActivePage = page;
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x....             LDR      R1,??DataTable15_1
   \       0x50   0x7008             STRB     R0,[R1, #+0]
   1282            uwAddressNextWrite = PAGE_HEADER_SIZE;
   \       0x52   0x2020             MOVS     R0,#+32
   \       0x54   0x....             LDR      R1,??DataTable15_2
   \       0x56   0x6008             STR      R0,[R1, #+0]
   1283          
   1284            /* Mark the erased page at receive state in case of normal transfer */
   1285            /* It is already the case in recover transfer case */
   1286            /* If program operation was failed, a Flash error code is returned */
   1287            if (Type == EE_TRANSFER_NORMAL)
   \       0x58   0xA80A             ADD      R0,SP,#+40
   \       0x5A   0x7800             LDRB     R0,[R0, #+0]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD107             BNE      ??PagesTransfer_4
   1288            {
   1289              if (SetPageState(page, STATE_PAGE_RECEIVE) != EE_OK)
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x....'....        BL       SetPageState
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD001             BEQ      ??PagesTransfer_4
   1290              {
   1291                return EE_WRITE_ERROR;
   \       0x6C   0x2002             MOVS     R0,#+2
   \       0x6E   0xE187             B        ??PagesTransfer_3
   1292              }
   1293            }
   1294          
   1295            /* Set the previous active page and all previous valid pages to erasing state */
   1296            /* In case of recover transfer, some of these pages may already be marked erasing */
   1297            page = PREVIOUS_PAGE(page);
   \                     ??PagesTransfer_4: (+1)
   \       0x70   0x26FF             MOVS     R6,#+255
   \       0x72   0x02B6             LSLS     R6,R6,#+10       ;; #+261120
   \       0x74   0x....             LDR      R5,??DataTable15_3  ;; 0x1fff75e0
   \       0x76   0x20D8             MOVS     R0,#+216
   \       0x78   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x7A   0x6829             LDR      R1,[R5, #+0]
   \       0x7C   0x0289             LSLS     R1,R1,#+10
   \       0x7E   0x4031             ANDS     R1,R1,R6
   \       0x80   0x....'....        BL       __aeabi_uidivmod
   \       0x84   0x0AC8             LSRS     R0,R1,#+11
   \       0x86   0x1A20             SUBS     R0,R4,R0
   \       0x88   0x3009             ADDS     R0,R0,#+9
   \       0x8A   0x210A             MOVS     R1,#+10
   \       0x8C   0x....'....        BL       __aeabi_uidivmod
   \       0x90   0x000C             MOVS     R4,R1
   \       0x92   0x20D8             MOVS     R0,#+216
   \       0x94   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x96   0x6829             LDR      R1,[R5, #+0]
   \       0x98   0x0289             LSLS     R1,R1,#+10
   \       0x9A   0x4031             ANDS     R1,R1,R6
   \       0x9C   0x....'....        BL       __aeabi_uidivmod
   \       0xA0   0x0AC8             LSRS     R0,R1,#+11
   \       0xA2   0x0021             MOVS     R1,R4
   \       0xA4   0x180C             ADDS     R4,R1,R0
   1298            pageaddress = PAGE_ADDRESS(page);
   \       0xA6   0x2180             MOVS     R1,#+128
   \       0xA8   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xAA   0x4361             MULS     R1,R4,R1
   \       0xAC   0x9100             STR      R1,[SP, #+0]
   \       0xAE   0x20D8             MOVS     R0,#+216
   \       0xB0   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0xB2   0x6829             LDR      R1,[R5, #+0]
   \       0xB4   0x0289             LSLS     R1,R1,#+10
   \       0xB6   0x4031             ANDS     R1,R1,R6
   \       0xB8   0x....'....        BL       __aeabi_uidiv
   \       0xBC   0x6829             LDR      R1,[R5, #+0]
   \       0xBE   0x0289             LSLS     R1,R1,#+10
   \       0xC0   0x4031             ANDS     R1,R1,R6
   \       0xC2   0x4348             MULS     R0,R1,R0
   \       0xC4   0x9900             LDR      R1,[SP, #+0]
   \       0xC6   0x1808             ADDS     R0,R1,R0
   \       0xC8   0x2180             MOVS     R1,#+128
   \       0xCA   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0xCC   0x1840             ADDS     R0,R0,R1
   \       0xCE   0x9002             STR      R0,[SP, #+8]
   1299            pagestatus = GetPageState(pageaddress);
   \       0xD0   0x9802             LDR      R0,[SP, #+8]
   \       0xD2   0x....'....        BL       GetPageState
   \       0xD6   0x4669             MOV      R1,SP
   \       0xD8   0x7108             STRB     R0,[R1, #+4]
   1300          
   1301            if ((pagestatus == STATE_PAGE_ACTIVE) || (pagestatus == STATE_PAGE_ERASING))
   \       0xDA   0x4668             MOV      R0,SP
   \       0xDC   0x7900             LDRB     R0,[R0, #+4]
   \       0xDE   0x2802             CMP      R0,#+2
   \       0xE0   0xD004             BEQ      ??PagesTransfer_5
   \       0xE2   0x4668             MOV      R0,SP
   \       0xE4   0x7900             LDRB     R0,[R0, #+4]
   \       0xE6   0x2804             CMP      R0,#+4
   \       0xE8   0xD000             BEQ      .+4
   \       0xEA   0xE081             B        ??PagesTransfer_6
   1302            {
   1303              /* Set active page to erasing */
   1304              if (pagestatus == STATE_PAGE_ACTIVE)
   \                     ??PagesTransfer_5: (+1)
   \       0xEC   0x4668             MOV      R0,SP
   \       0xEE   0x7900             LDRB     R0,[R0, #+4]
   \       0xF0   0x2802             CMP      R0,#+2
   \       0xF2   0xD107             BNE      ??PagesTransfer_7
   1305              {
   1306                if (SetPageState(page, STATE_PAGE_ERASING) != EE_OK)
   \       0xF4   0x2104             MOVS     R1,#+4
   \       0xF6   0x0020             MOVS     R0,R4
   \       0xF8   0x....'....        BL       SetPageState
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD001             BEQ      ??PagesTransfer_7
   1307                {
   1308                  return EE_WRITE_ERROR;
   \      0x100   0x2002             MOVS     R0,#+2
   \      0x102   0xE13D             B        ??PagesTransfer_3
   1309                }
   1310              }
   1311          
   1312              /* Inspect the previous pages to set all valid pages to erasing state */
   1313              /* In case of recover, some valid pages may be already erasing state */
   1314              page = PREVIOUS_PAGE(page);
   \                     ??PagesTransfer_7: (+1)
   \      0x104   0x20D8             MOVS     R0,#+216
   \      0x106   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \      0x108   0x6829             LDR      R1,[R5, #+0]
   \      0x10A   0x0289             LSLS     R1,R1,#+10
   \      0x10C   0x4031             ANDS     R1,R1,R6
   \      0x10E   0x....'....        BL       __aeabi_uidivmod
   \      0x112   0x0AC8             LSRS     R0,R1,#+11
   \      0x114   0x1A20             SUBS     R0,R4,R0
   \      0x116   0x3009             ADDS     R0,R0,#+9
   \      0x118   0x210A             MOVS     R1,#+10
   \      0x11A   0x....'....        BL       __aeabi_uidivmod
   \      0x11E   0x000C             MOVS     R4,R1
   \      0x120   0x20D8             MOVS     R0,#+216
   \      0x122   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \      0x124   0x6829             LDR      R1,[R5, #+0]
   \      0x126   0x0289             LSLS     R1,R1,#+10
   \      0x128   0x4031             ANDS     R1,R1,R6
   \      0x12A   0x....'....        BL       __aeabi_uidivmod
   \      0x12E   0x0AC8             LSRS     R0,R1,#+11
   \      0x130   0x0021             MOVS     R1,R4
   \      0x132   0x180C             ADDS     R4,R1,R0
   1315              pageaddress = PAGE_ADDRESS(page);
   \      0x134   0x2780             MOVS     R7,#+128
   \      0x136   0x013F             LSLS     R7,R7,#+4        ;; #+2048
   \      0x138   0x4367             MULS     R7,R4,R7
   \      0x13A   0x20D8             MOVS     R0,#+216
   \      0x13C   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \      0x13E   0x6829             LDR      R1,[R5, #+0]
   \      0x140   0x0289             LSLS     R1,R1,#+10
   \      0x142   0x4031             ANDS     R1,R1,R6
   \      0x144   0x....'....        BL       __aeabi_uidiv
   \      0x148   0x6829             LDR      R1,[R5, #+0]
   \      0x14A   0x0289             LSLS     R1,R1,#+10
   \      0x14C   0x4031             ANDS     R1,R1,R6
   \      0x14E   0x4348             MULS     R0,R1,R0
   \      0x150   0x1838             ADDS     R0,R7,R0
   \      0x152   0x2180             MOVS     R1,#+128
   \      0x154   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x156   0x1840             ADDS     R0,R0,R1
   \      0x158   0x9002             STR      R0,[SP, #+8]
   1316              pagestatus = GetPageState(pageaddress);
   \      0x15A   0x9802             LDR      R0,[SP, #+8]
   \      0x15C   0x....'....        BL       GetPageState
   \      0x160   0x4669             MOV      R1,SP
   \      0x162   0x7108             STRB     R0,[R1, #+4]
   1317          
   1318              while ((pagestatus == STATE_PAGE_VALID) || (pagestatus == STATE_PAGE_ERASING))
   \                     ??PagesTransfer_8: (+1)
   \      0x164   0x4668             MOV      R0,SP
   \      0x166   0x7900             LDRB     R0,[R0, #+4]
   \      0x168   0x2803             CMP      R0,#+3
   \      0x16A   0xD003             BEQ      ??PagesTransfer_9
   \      0x16C   0x4668             MOV      R0,SP
   \      0x16E   0x7900             LDRB     R0,[R0, #+4]
   \      0x170   0x2804             CMP      R0,#+4
   \      0x172   0xD147             BNE      ??PagesTransfer_10
   1319              {
   1320                /* Set valid page to erasing */
   1321                if (pagestatus == STATE_PAGE_VALID)
   \                     ??PagesTransfer_9: (+1)
   \      0x174   0x4668             MOV      R0,SP
   \      0x176   0x7900             LDRB     R0,[R0, #+4]
   \      0x178   0x2803             CMP      R0,#+3
   \      0x17A   0xD107             BNE      ??PagesTransfer_11
   1322                {
   1323                  if (SetPageState(page, STATE_PAGE_ERASING) != EE_OK)
   \      0x17C   0x2104             MOVS     R1,#+4
   \      0x17E   0x0020             MOVS     R0,R4
   \      0x180   0x....'....        BL       SetPageState
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD001             BEQ      ??PagesTransfer_11
   1324                  {
   1325                    return EE_WRITE_ERROR;
   \      0x188   0x2002             MOVS     R0,#+2
   \      0x18A   0xE0F9             B        ??PagesTransfer_3
   1326                  }
   1327                }
   1328          
   1329                /* decrement page index */
   1330                page = PREVIOUS_PAGE(page);
   \                     ??PagesTransfer_11: (+1)
   \      0x18C   0x27D8             MOVS     R7,#+216
   \      0x18E   0x027F             LSLS     R7,R7,#+9        ;; #+110592
   \      0x190   0x0038             MOVS     R0,R7
   \      0x192   0x6829             LDR      R1,[R5, #+0]
   \      0x194   0x0289             LSLS     R1,R1,#+10
   \      0x196   0x4031             ANDS     R1,R1,R6
   \      0x198   0x....'....        BL       __aeabi_uidivmod
   \      0x19C   0x0AC8             LSRS     R0,R1,#+11
   \      0x19E   0x1A20             SUBS     R0,R4,R0
   \      0x1A0   0x3009             ADDS     R0,R0,#+9
   \      0x1A2   0x210A             MOVS     R1,#+10
   \      0x1A4   0x....'....        BL       __aeabi_uidivmod
   \      0x1A8   0x000C             MOVS     R4,R1
   \      0x1AA   0x0038             MOVS     R0,R7
   \      0x1AC   0x6829             LDR      R1,[R5, #+0]
   \      0x1AE   0x0289             LSLS     R1,R1,#+10
   \      0x1B0   0x4031             ANDS     R1,R1,R6
   \      0x1B2   0x....'....        BL       __aeabi_uidivmod
   \      0x1B6   0x0AC8             LSRS     R0,R1,#+11
   \      0x1B8   0x0021             MOVS     R1,R4
   \      0x1BA   0x180C             ADDS     R4,R1,R0
   1331                pageaddress = PAGE_ADDRESS(page);
   \      0x1BC   0x2180             MOVS     R1,#+128
   \      0x1BE   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x1C0   0x4361             MULS     R1,R4,R1
   \      0x1C2   0x9100             STR      R1,[SP, #+0]
   \      0x1C4   0x0038             MOVS     R0,R7
   \      0x1C6   0x6829             LDR      R1,[R5, #+0]
   \      0x1C8   0x0289             LSLS     R1,R1,#+10
   \      0x1CA   0x4031             ANDS     R1,R1,R6
   \      0x1CC   0x....'....        BL       __aeabi_uidiv
   \      0x1D0   0x6829             LDR      R1,[R5, #+0]
   \      0x1D2   0x0289             LSLS     R1,R1,#+10
   \      0x1D4   0x4031             ANDS     R1,R1,R6
   \      0x1D6   0x4348             MULS     R0,R1,R0
   \      0x1D8   0x9900             LDR      R1,[SP, #+0]
   \      0x1DA   0x1808             ADDS     R0,R1,R0
   \      0x1DC   0x2180             MOVS     R1,#+128
   \      0x1DE   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x1E0   0x1840             ADDS     R0,R0,R1
   \      0x1E2   0x9002             STR      R0,[SP, #+8]
   1332                pagestatus = GetPageState(pageaddress);
   \      0x1E4   0x9802             LDR      R0,[SP, #+8]
   \      0x1E6   0x....'....        BL       GetPageState
   \      0x1EA   0x4669             MOV      R1,SP
   \      0x1EC   0x7108             STRB     R0,[R1, #+4]
   \      0x1EE   0xE7B9             B        ??PagesTransfer_8
   1333              }
   1334            }
   1335            else
   1336            {
   1337              if ((Type == EE_TRANSFER_RECOVER) && (pagestatus == STATE_PAGE_VALID))
   \                     ??PagesTransfer_6: (+1)
   \      0x1F0   0xA80A             ADD      R0,SP,#+40
   \      0x1F2   0x7800             LDRB     R0,[R0, #+0]
   \      0x1F4   0x2801             CMP      R0,#+1
   \      0x1F6   0xD103             BNE      ??PagesTransfer_12
   \      0x1F8   0x4668             MOV      R0,SP
   \      0x1FA   0x7900             LDRB     R0,[R0, #+4]
   \      0x1FC   0x2803             CMP      R0,#+3
   \      0x1FE   0xD001             BEQ      ??PagesTransfer_10
   1338              {
   1339                /* This can happen in case of recover transfer. It indicates that previous */
   1340                /* transfer goes far enough to fill a complete receive page at least */
   1341                /* (valid state). Then erasing state marking was already completed */
   1342              }
   1343              else
   1344              {
   1345                /* Inconsistent previous page state */
   1346                return EE_INVALID_PAGE_SEQUENCE;
   \                     ??PagesTransfer_12: (+1)
   \      0x200   0x200A             MOVS     R0,#+10
   \      0x202   0xE0BD             B        ??PagesTransfer_3
   1347              }
   1348            }
   1349          
   1350            /* In case of recover transfer, transfer must be resumed where it has been stopped */
   1351            /* Update global variables to reflect current transfer status */
   1352            if (Type == EE_TRANSFER_RECOVER)
   \                     ??PagesTransfer_10: (+1)
   \      0x204   0xA80A             ADD      R0,SP,#+40
   \      0x206   0x7800             LDRB     R0,[R0, #+0]
   \      0x208   0x2801             CMP      R0,#+1
   \      0x20A   0xD174             BNE      ??PagesTransfer_13
   1353            {
   1354              /* Count number of elements already transferred in current receive page */
   1355              for (varidx = PAGE_HEADER_SIZE; varidx < PAGE_SIZE; varidx += EE_ELEMENT_SIZE)
   \      0x20C   0x2720             MOVS     R7,#+32
   \                     ??PagesTransfer_14: (+1)
   \      0x20E   0x2080             MOVS     R0,#+128
   \      0x210   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x212   0x4287             CMP      R7,R0
   \      0x214   0xD22C             BCS      ??PagesTransfer_15
   1356              {
   1357                /* Get next element in receive page */
   1358                addressvalue = (*(__IO EE_ELEMENT_TYPE*)(PAGE_ADDRESS(ubCurrentActivePage) + varidx));
   \      0x216   0x....             LDR      R0,??DataTable15_1
   \      0x218   0x7801             LDRB     R1,[R0, #+0]
   \      0x21A   0x2080             MOVS     R0,#+128
   \      0x21C   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \      0x21E   0x4341             MULS     R1,R0,R1
   \      0x220   0x9100             STR      R1,[SP, #+0]
   \      0x222   0x20D8             MOVS     R0,#+216
   \      0x224   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \      0x226   0x6829             LDR      R1,[R5, #+0]
   \      0x228   0x0289             LSLS     R1,R1,#+10
   \      0x22A   0x4031             ANDS     R1,R1,R6
   \      0x22C   0x....'....        BL       __aeabi_uidiv
   \      0x230   0x6829             LDR      R1,[R5, #+0]
   \      0x232   0x0289             LSLS     R1,R1,#+10
   \      0x234   0x4031             ANDS     R1,R1,R6
   \      0x236   0x4348             MULS     R0,R1,R0
   \      0x238   0x9900             LDR      R1,[SP, #+0]
   \      0x23A   0x1808             ADDS     R0,R1,R0
   \      0x23C   0x19C0             ADDS     R0,R0,R7
   \      0x23E   0x2180             MOVS     R1,#+128
   \      0x240   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x242   0x1840             ADDS     R0,R0,R1
   \      0x244   0xC803             LDM      R0,{R0,R1}
   \      0x246   0xAA06             ADD      R2,SP,#+24
   \      0x248   0xC203             STM      R2!,{R0,R1}
   \      0x24A   0x3A08             SUBS     R2,R2,#+8
   1359          
   1360                /* Check if element is valid */
   1361                if (addressvalue != EE_PAGESTAT_ERASED)
   \      0x24C   0xA806             ADD      R0,SP,#+24
   \      0x24E   0xC803             LDM      R0,{R0,R1}
   \      0x250   0x....             ADR      R2,??DataTable16
   \      0x252   0xCA0C             LDM      R2,{R2,R3}
   \      0x254   0x4299             CMP      R1,R3
   \      0x256   0xD101             BNE      ??PagesTransfer_16
   \      0x258   0x4290             CMP      R0,R2
   \      0x25A   0xD009             BEQ      ??PagesTransfer_17
   1362                {
   1363                  /* Update global variables accordingly */
   1364                  uhNbWrittenElements++;
   \                     ??PagesTransfer_16: (+1)
   \      0x25C   0x....             LDR      R0,??DataTable15
   \      0x25E   0x8801             LDRH     R1,[R0, #+0]
   \      0x260   0x1C49             ADDS     R1,R1,#+1
   \      0x262   0x8001             STRH     R1,[R0, #+0]
   1365                  uwAddressNextWrite += EE_ELEMENT_SIZE;
   \      0x264   0x....             LDR      R0,??DataTable15_2
   \      0x266   0x6801             LDR      R1,[R0, #+0]
   \      0x268   0x3108             ADDS     R1,R1,#+8
   \      0x26A   0x6001             STR      R1,[R0, #+0]
   1366                }
   \      0x26C   0x3708             ADDS     R7,R7,#+8
   \      0x26E   0xE7CE             B        ??PagesTransfer_14
   1367                else
   1368                {
   1369                  break;
   1370                }
   1371              }
   1372          
   1373              /* Count number of elements already transferred in previous valid pages */
   1374              page = ubCurrentActivePage;
   \                     ??PagesTransfer_17: (+1)
   \                     ??PagesTransfer_15: (+1)
   \      0x270   0x....             LDR      R0,??DataTable15_1
   \      0x272   0x7800             LDRB     R0,[R0, #+0]
   \      0x274   0x0004             MOVS     R4,R0
   1375              for (varidx = 0U; varidx < PAGES_NUMBER; varidx++)
   \      0x276   0x2000             MOVS     R0,#+0
   \      0x278   0x9003             STR      R0,[SP, #+12]
   \                     ??PagesTransfer_18: (+1)
   \      0x27A   0x9803             LDR      R0,[SP, #+12]
   \      0x27C   0x280A             CMP      R0,#+10
   \      0x27E   0xD23A             BCS      ??PagesTransfer_13
   1376              {
   1377                /* Decrement page index among circular pages list */
   1378                page = PREVIOUS_PAGE(page);
   \      0x280   0x27D8             MOVS     R7,#+216
   \      0x282   0x027F             LSLS     R7,R7,#+9        ;; #+110592
   \      0x284   0x0038             MOVS     R0,R7
   \      0x286   0x6829             LDR      R1,[R5, #+0]
   \      0x288   0x0289             LSLS     R1,R1,#+10
   \      0x28A   0x4031             ANDS     R1,R1,R6
   \      0x28C   0x....'....        BL       __aeabi_uidivmod
   \      0x290   0x0AC8             LSRS     R0,R1,#+11
   \      0x292   0x1A20             SUBS     R0,R4,R0
   \      0x294   0x3009             ADDS     R0,R0,#+9
   \      0x296   0x210A             MOVS     R1,#+10
   \      0x298   0x....'....        BL       __aeabi_uidivmod
   \      0x29C   0x000C             MOVS     R4,R1
   \      0x29E   0x0038             MOVS     R0,R7
   \      0x2A0   0x6829             LDR      R1,[R5, #+0]
   \      0x2A2   0x0289             LSLS     R1,R1,#+10
   \      0x2A4   0x4031             ANDS     R1,R1,R6
   \      0x2A6   0x....'....        BL       __aeabi_uidivmod
   \      0x2AA   0x0AC8             LSRS     R0,R1,#+11
   \      0x2AC   0x0021             MOVS     R1,R4
   \      0x2AE   0x180C             ADDS     R4,R1,R0
   1379                pagestatus = GetPageState(PAGE_ADDRESS(page));
   \      0x2B0   0x2180             MOVS     R1,#+128
   \      0x2B2   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x2B4   0x4361             MULS     R1,R4,R1
   \      0x2B6   0x9100             STR      R1,[SP, #+0]
   \      0x2B8   0x0038             MOVS     R0,R7
   \      0x2BA   0x6829             LDR      R1,[R5, #+0]
   \      0x2BC   0x0289             LSLS     R1,R1,#+10
   \      0x2BE   0x4031             ANDS     R1,R1,R6
   \      0x2C0   0x....'....        BL       __aeabi_uidiv
   \      0x2C4   0x6829             LDR      R1,[R5, #+0]
   \      0x2C6   0x0289             LSLS     R1,R1,#+10
   \      0x2C8   0x4031             ANDS     R1,R1,R6
   \      0x2CA   0x4348             MULS     R0,R1,R0
   \      0x2CC   0x9900             LDR      R1,[SP, #+0]
   \      0x2CE   0x1808             ADDS     R0,R1,R0
   \      0x2D0   0x2180             MOVS     R1,#+128
   \      0x2D2   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \      0x2D4   0x1840             ADDS     R0,R0,R1
   \      0x2D6   0x....'....        BL       GetPageState
   \      0x2DA   0x4669             MOV      R1,SP
   \      0x2DC   0x7108             STRB     R0,[R1, #+4]
   1380          
   1381                /* Check if page is valid state */
   1382                if (pagestatus == STATE_PAGE_VALID)
   \      0x2DE   0x4668             MOV      R0,SP
   \      0x2E0   0x7900             LDRB     R0,[R0, #+4]
   \      0x2E2   0x2803             CMP      R0,#+3
   \      0x2E4   0xD107             BNE      ??PagesTransfer_19
   1383                {
   1384                  /* Update uhNbWrittenElements with number of elements in page */
   1385                  uhNbWrittenElements += NB_MAX_ELEMENTS_BY_PAGE;
   \      0x2E6   0x....             LDR      R0,??DataTable15
   \      0x2E8   0x8801             LDRH     R1,[R0, #+0]
   \      0x2EA   0x31FC             ADDS     R1,R1,#+252
   \      0x2EC   0x8001             STRH     R1,[R0, #+0]
   1386                }
   \      0x2EE   0x9803             LDR      R0,[SP, #+12]
   \      0x2F0   0x1C40             ADDS     R0,R0,#+1
   \      0x2F2   0x9003             STR      R0,[SP, #+12]
   \      0x2F4   0xE7C1             B        ??PagesTransfer_18
   1387                else
   1388                {
   1389                  break;
   1390                }
   1391              }
   1392            }
   1393          
   1394          #ifdef DUALCORE_FLASH_SHARING  
   1395            if (VerifyPagesFullWriteVariable(VirtAddress, Data, EE_TRANSFER) != EE_OK)
   1396            {
   1397              return EE_WRITE_ERROR;
   1398            }
   1399          #else
   1400            /* Write the variable passed as parameter in the new active page */
   1401            /* If program operation was failed, a Flash error code is returned */
   1402            if (VerifyPagesFullWriteVariable(VirtAddress, Data) != EE_OK)
   \                     ??PagesTransfer_19: (+1)
   \                     ??PagesTransfer_13: (+1)
   \      0x2F6   0x9909             LDR      R1,[SP, #+36]
   \      0x2F8   0x4668             MOV      R0,SP
   \      0x2FA   0x8C00             LDRH     R0,[R0, #+32]
   \      0x2FC   0x....'....        BL       VerifyPagesFullWriteVariable
   \      0x300   0x2800             CMP      R0,#+0
   \      0x302   0xD001             BEQ      ??PagesTransfer_20
   1403            {
   1404              return EE_WRITE_ERROR;
   \      0x304   0x2002             MOVS     R0,#+2
   \      0x306   0xE03B             B        ??PagesTransfer_3
   1405            }
   1406          #endif
   1407          
   1408            /* Transfer process: transfer variables from old to the new active page */
   1409            /* First element in receive page can be any one, the following elements are */
   1410            /* ordered from the beginning. */
   1411            /* In case of recovery, Pre-Last element in receive page could be */
   1412            /* corrupted if reset occured during write of this element, */
   1413            /* and last element is dummy value that we have just written. */
   1414            /* Transfer shall then resume from (uhNbWrittenElements-3) variable index */
   1415            for (varidx = (uhNbWrittenElements >= 3U?(uhNbWrittenElements-3U+1U):1U); varidx < NB_OF_VARIABLES+1; varidx++)
   \                     ??PagesTransfer_20: (+1)
   \      0x308   0x....             LDR      R0,??DataTable15
   \      0x30A   0x8801             LDRH     R1,[R0, #+0]
   \      0x30C   0x2903             CMP      R1,#+3
   \      0x30E   0xD302             BCC      ??PagesTransfer_21
   \      0x310   0x8800             LDRH     R0,[R0, #+0]
   \      0x312   0x1E85             SUBS     R5,R0,#+2
   \      0x314   0xE000             B        ??PagesTransfer_22
   \                     ??PagesTransfer_21: (+1)
   \      0x316   0x2501             MOVS     R5,#+1
   \                     ??PagesTransfer_22: (+1)
   \      0x318   0x....             LDR      R0,??DataTable17  ;; 0x3e9
   \      0x31A   0x4285             CMP      R5,R0
   \      0x31C   0xD225             BCS      ??PagesTransfer_23
   1416            {
   1417              /* Check each variable except the one passed as parameter */
   1418              if (varidx != VirtAddress)
   \      0x31E   0x4668             MOV      R0,SP
   \      0x320   0x8C00             LDRH     R0,[R0, #+32]
   \      0x322   0x4285             CMP      R5,R0
   \      0x324   0xD01F             BEQ      ??PagesTransfer_24
   1419              {
   1420                /* Read the last variable updates */
   1421                status = ReadVariable(varidx, &DataValue);
   \      0x326   0xA904             ADD      R1,SP,#+16
   \      0x328   0x0028             MOVS     R0,R5
   \      0x32A   0xB280             UXTH     R0,R0
   \      0x32C   0x....'....        BL       ReadVariable
   \      0x330   0x4669             MOV      R1,SP
   \      0x332   0x80C8             STRH     R0,[R1, #+6]
   1422                if (status == EE_OK)
   \      0x334   0x9801             LDR      R0,[SP, #+4]
   \      0x336   0x1400             ASRS     R0,R0,#+16
   \      0x338   0x2800             CMP      R0,#+0
   \      0x33A   0xD10D             BNE      ??PagesTransfer_25
   1423                {
   1424                  /* In case variable corresponding to the virtual address was found */
   1425                  /* Transfer the variable to the new active page */
   1426                  /* If program operation was failed, a Flash error code is returned */
   1427                  #ifdef DUALCORE_FLASH_SHARING
   1428                  status = VerifyPagesFullWriteVariable(varidx, DataValue, EE_TRANSFER);
   1429                  #else
   1430                  status = VerifyPagesFullWriteVariable(varidx, DataValue);
   \      0x33C   0x9904             LDR      R1,[SP, #+16]
   \      0x33E   0x0028             MOVS     R0,R5
   \      0x340   0xB280             UXTH     R0,R0
   \      0x342   0x....'....        BL       VerifyPagesFullWriteVariable
   \      0x346   0x4669             MOV      R1,SP
   \      0x348   0x80C8             STRH     R0,[R1, #+6]
   1431                  #endif
   1432                  if (status != EE_OK)
   \      0x34A   0x9801             LDR      R0,[SP, #+4]
   \      0x34C   0x1400             ASRS     R0,R0,#+16
   \      0x34E   0x2800             CMP      R0,#+0
   \      0x350   0xD009             BEQ      ??PagesTransfer_24
   1433                  {
   1434                    return status;
   \      0x352   0x9801             LDR      R0,[SP, #+4]
   \      0x354   0x1400             ASRS     R0,R0,#+16
   \      0x356   0xE013             B        ??PagesTransfer_3
   1435                  }
   1436                }
   1437                else
   1438                {
   1439                  if (status != EE_NO_DATA)
   \                     ??PagesTransfer_25: (+1)
   \      0x358   0x9801             LDR      R0,[SP, #+4]
   \      0x35A   0x1400             ASRS     R0,R0,#+16
   \      0x35C   0x2807             CMP      R0,#+7
   \      0x35E   0xD002             BEQ      ??PagesTransfer_24
   1440                  {
   1441                    /* In case variable is not found , do nothing */
   1442                    /* Any other status is error code occurs during variable read */
   1443                    return status;
   \      0x360   0x9801             LDR      R0,[SP, #+4]
   \      0x362   0x1400             ASRS     R0,R0,#+16
   \      0x364   0xE00C             B        ??PagesTransfer_3
   1444                  }
   1445                }
   1446              }
   1447            }
   \                     ??PagesTransfer_24: (+1)
   \      0x366   0x1C6D             ADDS     R5,R5,#+1
   \      0x368   0xE7D6             B        ??PagesTransfer_22
   1448          
   1449            /* Transfer is now done, mark the receive state page as active */
   1450            if (SetPageState(ubCurrentActivePage, STATE_PAGE_ACTIVE) != EE_OK)
   \                     ??PagesTransfer_23: (+1)
   \      0x36A   0x2102             MOVS     R1,#+2
   \      0x36C   0x....             LDR      R0,??DataTable15_1
   \      0x36E   0x7800             LDRB     R0,[R0, #+0]
   \      0x370   0x....'....        BL       SetPageState
   \      0x374   0x2800             CMP      R0,#+0
   \      0x376   0xD001             BEQ      ??PagesTransfer_26
   1451            {
   1452              return EE_WRITE_ERROR;
   \      0x378   0x2002             MOVS     R0,#+2
   \      0x37A   0xE001             B        ??PagesTransfer_3
   1453            }
   1454          
   1455            /* Return last operation flash status */
   1456            return EE_CLEANUP_REQUIRED;
   \                     ??PagesTransfer_26: (+1)
   \      0x37C   0x2080             MOVS     R0,#+128
   \      0x37E   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \                     ??PagesTransfer_3: (+1)
   \      0x380   0xB00B             ADD      SP,SP,#+44
   \      0x382   0xBDF0             POP      {R4-R7,PC}       ;; return
   1457          }
   1458          
   1459          /**
   1460            * @brief  Verify if pages are full
   1461            *   then if not the case, writes variable in EEPROM.
   1462            * @param  VirtAddress 16 bit virtual address of the variable
   1463            * @param  Data @ref EE_DATA_TYPE data to be written as variable value
   1464            * @param  Write_type Type of writing on going (see EE_Write_type)
   1465            * @retval EE_Status
   1466            *           - EE_OK: on success
   1467            *           - EE_FULL: if half pages are full
   1468            *           - EE_FLASH_USED: flash currently used by CPU2
   1469            *           - EE error code: if an error occurs
   1470            */
   1471          #ifdef DUALCORE_FLASH_SHARING
   1472          static EE_Status VerifyPagesFullWriteVariable(uint16_t VirtAddress, EE_DATA_TYPE Data, EE_Write_type Write_type)
   1473          #else

   \                                 In section .text, align 2, keep-with-next
   1474          static EE_Status VerifyPagesFullWriteVariable(uint16_t VirtAddress, EE_DATA_TYPE Data)
   1475          #endif
   1476          {
   \                     VerifyPagesFullWriteVariable: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   1477            uint32_t crc = 0U;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x9403             STR      R4,[SP, #+12]
   1478          
   1479            /* Check if pages are full, i.e. max number of written elements achieved */
   1480            if (uhNbWrittenElements >= NB_MAX_WRITTEN_ELEMENTS)
   \        0x8   0x....             LDR      R6,??DataTable20
   \        0xA   0x8830             LDRH     R0,[R6, #+0]
   \        0xC   0x....             LDR      R1,??DataTable20_1  ;; 0x4ec
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD301             BCC      ??VerifyPagesFullWriteVariable_0
   1481            {
   1482              return EE_PAGE_FULL;
   \       0x12   0x2012             MOVS     R0,#+18
   \       0x14   0xE047             B        ??VerifyPagesFullWriteVariable_1
   1483            }
   1484          
   1485            /* Get active Page for write operation */
   1486            uint32_t activepage = FindPage(FIND_WRITE_PAGE);
   \                     ??VerifyPagesFullWriteVariable_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x....'....        BL       FindPage
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   1487            uint32_t activepageaddress = 0U;
   \       0x1E   0x9402             STR      R4,[SP, #+8]
   1488          
   1489            /* Check if there is no active page */
   1490            if (activepage == EE_NO_PAGE_FOUND)
   \       0x20   0x9801             LDR      R0,[SP, #+4]
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x43C9             MVNS     R1,R1            ;; #-1
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD101             BNE      ??VerifyPagesFullWriteVariable_2
   1491            {
   1492              return EE_ERROR_NOACTIVE_PAGE;
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0xE03B             B        ??VerifyPagesFullWriteVariable_1
   1493            }
   1494          
   1495            activepageaddress = PAGE_ADDRESS(activepage);
   \                     ??VerifyPagesFullWriteVariable_2: (+1)
   \       0x2E   0x25FF             MOVS     R5,#+255
   \       0x30   0x02AD             LSLS     R5,R5,#+10       ;; #+261120
   \       0x32   0x....             LDR      R7,??DataTable20_2  ;; 0x1fff75e0
   \       0x34   0x9901             LDR      R1,[SP, #+4]
   \       0x36   0x2080             MOVS     R0,#+128
   \       0x38   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \       0x3A   0x4341             MULS     R1,R0,R1
   \       0x3C   0x9100             STR      R1,[SP, #+0]
   \       0x3E   0x20D8             MOVS     R0,#+216
   \       0x40   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x42   0x6839             LDR      R1,[R7, #+0]
   \       0x44   0x0289             LSLS     R1,R1,#+10
   \       0x46   0x4029             ANDS     R1,R1,R5
   \       0x48   0x....'....        BL       __aeabi_uidiv
   \       0x4C   0x6839             LDR      R1,[R7, #+0]
   \       0x4E   0x0289             LSLS     R1,R1,#+10
   \       0x50   0x400D             ANDS     R5,R5,R1
   \       0x52   0x4368             MULS     R0,R5,R0
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   \       0x56   0x1808             ADDS     R0,R1,R0
   \       0x58   0x2180             MOVS     R1,#+128
   \       0x5A   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x5C   0x1847             ADDS     R7,R0,R1
   1496          
   1497            /* Force crc to 0 in case of Data/VirtAddress are 0*/
   1498            if ((Data == 0U) && (VirtAddress == 0U))
   \       0x5E   0x9806             LDR      R0,[SP, #+24]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD103             BNE      ??VerifyPagesFullWriteVariable_3
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x8A80             LDRH     R0,[R0, #+20]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD005             BEQ      ??VerifyPagesFullWriteVariable_4
   1499            {
   1500              crc = 0U;
   1501            }
   1502            else
   1503            {
   1504              /* Calculate crc of variable data and virtual address */
   1505              crc = CalculateCrc(Data, VirtAddress);
   \                     ??VerifyPagesFullWriteVariable_3: (+1)
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x8A81             LDRH     R1,[R0, #+20]
   \       0x70   0x9806             LDR      R0,[SP, #+24]
   \       0x72   0x....'....        BL       CalculateCrc
   \       0x76   0x0004             MOVS     R4,R0
   1506            }
   1507          
   1508          #ifdef DUALCORE_FLASH_SHARING
   1509            /* Program variable data + virtual address + crc */
   1510            /* If program operation was failed, a Flash error code or the information
   1511                about the semaphore monitoring flash being taken is returned */
   1512            EE_Status ee_status = FI_WriteDoubleWord(activepageaddress+uwAddressNextWrite, EE_ELEMENT_VALUE(VirtAddress,Data,crc), Write_type);
   1513            if (ee_status != EE_OK) return ee_status;  
   1514          #else
   1515            /* Program variable data + virtual address + crc */
   1516            /* If program operation was failed, a Flash error code is returned */
   1517            if (FI_WriteDoubleWord(activepageaddress+uwAddressNextWrite, EE_ELEMENT_VALUE(VirtAddress,Data,crc)) != HAL_OK)
   \                     ??VerifyPagesFullWriteVariable_4: (+1)
   \       0x78   0x....             LDR      R5,??DataTable20_8
   \       0x7A   0x9906             LDR      R1,[SP, #+24]
   \       0x7C   0x0420             LSLS     R0,R4,#+16
   \       0x7E   0x466A             MOV      R2,SP
   \       0x80   0x8A92             LDRH     R2,[R2, #+20]
   \       0x82   0x2300             MOVS     R3,#+0
   \       0x84   0x4302             ORRS     R2,R2,R0
   \       0x86   0x430B             ORRS     R3,R3,R1
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x1838             ADDS     R0,R7,R0
   \       0x8C   0x....'....        BL       FI_WriteDoubleWord
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD001             BEQ      ??VerifyPagesFullWriteVariable_5
   1518            {
   1519              return EE_WRITE_ERROR;
   \       0x94   0x2002             MOVS     R0,#+2
   \       0x96   0xE006             B        ??VerifyPagesFullWriteVariable_1
   1520            }
   1521          #endif
   1522          
   1523            /* Increment global variables relative to write operation done*/
   1524            uwAddressNextWrite += EE_ELEMENT_SIZE;
   \                     ??VerifyPagesFullWriteVariable_5: (+1)
   \       0x98   0x6828             LDR      R0,[R5, #+0]
   \       0x9A   0x3008             ADDS     R0,R0,#+8
   \       0x9C   0x6028             STR      R0,[R5, #+0]
   1525            uhNbWrittenElements++;
   \       0x9E   0x8830             LDRH     R0,[R6, #+0]
   \       0xA0   0x1C40             ADDS     R0,R0,#+1
   \       0xA2   0x8030             STRH     R0,[R6, #+0]
   1526          
   1527            return EE_OK;
   \       0xA4   0x2000             MOVS     R0,#+0
   \                     ??VerifyPagesFullWriteVariable_1: (+1)
   \       0xA6   0xB007             ADD      SP,SP,#+28
   \       0xA8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1528          }
   1529          
   1530          /**
   1531            * @brief  Set page state in page header
   1532            * @param  Page Index of the page
   1533            * @param  State State of the page
   1534            * @retval EE_Status
   1535            *           - EE_OK: on success
   1536            *           - EE error code: if an error occurs
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          static EE_Status SetPageState(uint32_t Page, EE_State_type State)
   1539          {
   \                     SetPageState: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   1540            uint32_t header1 = 0U, header2 = 0U, header3 = 0U, header4 = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9003             STR      R0,[SP, #+12]
   \        0xA   0x9002             STR      R0,[SP, #+8]
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x9004             STR      R0,[SP, #+16]
   1541          
   1542            header1 = PAGE_ADDRESS(Page);
   \       0x10   0x25FF             MOVS     R5,#+255
   \       0x12   0x02AD             LSLS     R5,R5,#+10       ;; #+261120
   \       0x14   0x....             LDR      R6,??DataTable20_2  ;; 0x1fff75e0
   \       0x16   0x2780             MOVS     R7,#+128
   \       0x18   0x013F             LSLS     R7,R7,#+4        ;; #+2048
   \       0x1A   0x0021             MOVS     R1,R4
   \       0x1C   0x4379             MULS     R1,R7,R1
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   \       0x20   0x20D8             MOVS     R0,#+216
   \       0x22   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x24   0x6831             LDR      R1,[R6, #+0]
   \       0x26   0x0289             LSLS     R1,R1,#+10
   \       0x28   0x4029             ANDS     R1,R1,R5
   \       0x2A   0x....'....        BL       __aeabi_uidiv
   \       0x2E   0x6831             LDR      R1,[R6, #+0]
   \       0x30   0x0289             LSLS     R1,R1,#+10
   \       0x32   0x4029             ANDS     R1,R1,R5
   \       0x34   0x4348             MULS     R0,R1,R0
   \       0x36   0x9900             LDR      R1,[SP, #+0]
   \       0x38   0x1808             ADDS     R0,R1,R0
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \       0x3E   0x1840             ADDS     R0,R0,R1
   \       0x40   0x9003             STR      R0,[SP, #+12]
   1543            header2 = PAGE_ADDRESS(Page) + EE_ELEMENT_SIZE;
   \       0x42   0x0021             MOVS     R1,R4
   \       0x44   0x4379             MULS     R1,R7,R1
   \       0x46   0x9100             STR      R1,[SP, #+0]
   \       0x48   0x20D8             MOVS     R0,#+216
   \       0x4A   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x4C   0x6831             LDR      R1,[R6, #+0]
   \       0x4E   0x0289             LSLS     R1,R1,#+10
   \       0x50   0x4029             ANDS     R1,R1,R5
   \       0x52   0x....'....        BL       __aeabi_uidiv
   \       0x56   0x6831             LDR      R1,[R6, #+0]
   \       0x58   0x0289             LSLS     R1,R1,#+10
   \       0x5A   0x4029             ANDS     R1,R1,R5
   \       0x5C   0x4348             MULS     R0,R1,R0
   \       0x5E   0x9900             LDR      R1,[SP, #+0]
   \       0x60   0x1808             ADDS     R0,R1,R0
   \       0x62   0x....             LDR      R1,??DataTable20_3  ;; 0x8000008
   \       0x64   0x1840             ADDS     R0,R0,R1
   \       0x66   0x9002             STR      R0,[SP, #+8]
   1544            header3 = PAGE_ADDRESS(Page) + (EE_ELEMENT_SIZE*2U);
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0x4379             MULS     R1,R7,R1
   \       0x6C   0x9100             STR      R1,[SP, #+0]
   \       0x6E   0x20D8             MOVS     R0,#+216
   \       0x70   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x72   0x6831             LDR      R1,[R6, #+0]
   \       0x74   0x0289             LSLS     R1,R1,#+10
   \       0x76   0x4029             ANDS     R1,R1,R5
   \       0x78   0x....'....        BL       __aeabi_uidiv
   \       0x7C   0x6831             LDR      R1,[R6, #+0]
   \       0x7E   0x0289             LSLS     R1,R1,#+10
   \       0x80   0x4029             ANDS     R1,R1,R5
   \       0x82   0x4348             MULS     R0,R1,R0
   \       0x84   0x9900             LDR      R1,[SP, #+0]
   \       0x86   0x1808             ADDS     R0,R1,R0
   \       0x88   0x....             LDR      R1,??DataTable20_4  ;; 0x8000010
   \       0x8A   0x1840             ADDS     R0,R0,R1
   \       0x8C   0x9001             STR      R0,[SP, #+4]
   1545            header4 = PAGE_ADDRESS(Page) + (EE_ELEMENT_SIZE*3U);
   \       0x8E   0x4367             MULS     R7,R4,R7
   \       0x90   0x20D8             MOVS     R0,#+216
   \       0x92   0x0240             LSLS     R0,R0,#+9        ;; #+110592
   \       0x94   0x6831             LDR      R1,[R6, #+0]
   \       0x96   0x0289             LSLS     R1,R1,#+10
   \       0x98   0x4029             ANDS     R1,R1,R5
   \       0x9A   0x....'....        BL       __aeabi_uidiv
   \       0x9E   0x6831             LDR      R1,[R6, #+0]
   \       0xA0   0x0289             LSLS     R1,R1,#+10
   \       0xA2   0x400D             ANDS     R5,R5,R1
   \       0xA4   0x4368             MULS     R0,R5,R0
   \       0xA6   0x1838             ADDS     R0,R7,R0
   \       0xA8   0x....             LDR      R1,??DataTable20_5  ;; 0x8000018
   \       0xAA   0x1845             ADDS     R5,R0,R1
   1546          
   1547          #ifdef DUALCORE_FLASH_SHARING
   1548            EE_Status ee_status;
   1549            switch(State)
   1550            {
   1551            case STATE_PAGE_RECEIVE:
   1552              {
   1553                /* Set new Page status to STATE_PAGE_RECEIVE status */
   1554                ee_status = FI_WriteDoubleWord(header1, EE_PAGESTAT_RECEIVE, EE_SET_PAGE);
   1555                if (ee_status != EE_OK) return ee_status;
   1556                ubCurrentActivePage = Page;
   1557              }
   1558              break;
   1559            case STATE_PAGE_ACTIVE:
   1560              {
   1561                /* Set new Page status to STATE_PAGE_ACTIVE status */
   1562                ee_status = FI_WriteDoubleWord(header2, EE_PAGESTAT_ACTIVE, EE_SET_PAGE);
   1563                if (ee_status != EE_OK) return ee_status;
   1564                ubCurrentActivePage = Page;
   1565              }
   1566              break;
   1567            case STATE_PAGE_VALID:
   1568              {
   1569                /* Set new Page status to STATE_PAGE_VALID status */
   1570                ee_status = FI_WriteDoubleWord(header3, EE_PAGESTAT_VALID, EE_SET_PAGE);
   1571                if (ee_status != EE_OK) return ee_status;
   1572              }
   1573              break;
   1574            case STATE_PAGE_ERASING:
   1575              {
   1576                /* Set new Page status to STATE_PAGE_ERASING status */
   1577                ee_status = FI_WriteDoubleWord(header4, EE_PAGESTAT_ERASING, EE_SET_PAGE);
   1578                if (ee_status != EE_OK) return ee_status;
   1579              }
   1580              break;
   1581            default:
   1582              break;
   1583            }
   1584          #else
   1585            switch(State)
   \       0xAC   0x4668             MOV      R0,SP
   \       0xAE   0x7E00             LDRB     R0,[R0, #+24]
   \       0xB0   0x2801             CMP      R0,#+1
   \       0xB2   0xD006             BEQ      ??SetPageState_0
   \       0xB4   0xD333             BCC      ??SetPageState_1
   \       0xB6   0x2803             CMP      R0,#+3
   \       0xB8   0xD01D             BEQ      ??SetPageState_2
   \       0xBA   0xD30F             BCC      ??SetPageState_3
   \       0xBC   0x2804             CMP      R0,#+4
   \       0xBE   0xD024             BEQ      ??SetPageState_4
   \       0xC0   0xE02D             B        ??SetPageState_1
   1586            {
   1587            case STATE_PAGE_RECEIVE:
   1588              {
   1589                /* Set new Page status to STATE_PAGE_RECEIVE status */
   1590                if (FI_WriteDoubleWord(header1, EE_PAGESTAT_RECEIVE) != HAL_OK)
   \                     ??SetPageState_0: (+1)
   \       0xC2   0x....             ADR      R2,??DataTable20_9
   \       0xC4   0xCA0C             LDM      R2,{R2,R3}
   \       0xC6   0x9803             LDR      R0,[SP, #+12]
   \       0xC8   0x....'....        BL       FI_WriteDoubleWord
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD001             BEQ      ??SetPageState_5
   1591                {
   1592                  return EE_WRITE_ERROR;
   \       0xD0   0x2002             MOVS     R0,#+2
   \       0xD2   0xE025             B        ??SetPageState_6
   1593                }
   1594                ubCurrentActivePage = Page;
   \                     ??SetPageState_5: (+1)
   \       0xD4   0x0020             MOVS     R0,R4
   \       0xD6   0x....             LDR      R1,??DataTable20_6
   \       0xD8   0x7008             STRB     R0,[R1, #+0]
   1595              }
   1596              break;
   \       0xDA   0xE020             B        ??SetPageState_7
   1597            case STATE_PAGE_ACTIVE:
   1598              {
   1599                /* Set new Page status to STATE_PAGE_ACTIVE status */
   1600                if (FI_WriteDoubleWord(header2, EE_PAGESTAT_ACTIVE) != HAL_OK)
   \                     ??SetPageState_3: (+1)
   \       0xDC   0x....             ADR      R2,??DataTable20_9
   \       0xDE   0xCA0C             LDM      R2,{R2,R3}
   \       0xE0   0x9802             LDR      R0,[SP, #+8]
   \       0xE2   0x....'....        BL       FI_WriteDoubleWord
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD001             BEQ      ??SetPageState_8
   1601                {
   1602                  return EE_WRITE_ERROR;
   \       0xEA   0x2002             MOVS     R0,#+2
   \       0xEC   0xE018             B        ??SetPageState_6
   1603                }
   1604                ubCurrentActivePage = Page;
   \                     ??SetPageState_8: (+1)
   \       0xEE   0x0020             MOVS     R0,R4
   \       0xF0   0x....             LDR      R1,??DataTable20_6
   \       0xF2   0x7008             STRB     R0,[R1, #+0]
   1605              }
   1606              break;
   \       0xF4   0xE013             B        ??SetPageState_7
   1607            case STATE_PAGE_VALID:
   1608              {
   1609                /* Set new Page status to STATE_PAGE_VALID status */
   1610                if (FI_WriteDoubleWord(header3, EE_PAGESTAT_VALID) != HAL_OK)
   \                     ??SetPageState_2: (+1)
   \       0xF6   0x....             ADR      R2,??DataTable20_9
   \       0xF8   0xCA0C             LDM      R2,{R2,R3}
   \       0xFA   0x9801             LDR      R0,[SP, #+4]
   \       0xFC   0x....'....        BL       FI_WriteDoubleWord
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD001             BEQ      ??SetPageState_9
   1611                {
   1612                  return EE_WRITE_ERROR;
   \      0x104   0x2002             MOVS     R0,#+2
   \      0x106   0xE00B             B        ??SetPageState_6
   1613                }
   1614              }
   1615              break;
   \                     ??SetPageState_9: (+1)
   \      0x108   0xE009             B        ??SetPageState_7
   1616            case STATE_PAGE_ERASING:
   1617              {
   1618                /* Set new Page status to STATE_PAGE_ERASING status */
   1619                if (FI_WriteDoubleWord(header4, EE_PAGESTAT_ERASING) != HAL_OK)
   \                     ??SetPageState_4: (+1)
   \      0x10A   0x....             ADR      R2,??DataTable20_9
   \      0x10C   0xCA0C             LDM      R2,{R2,R3}
   \      0x10E   0x0028             MOVS     R0,R5
   \      0x110   0x....'....        BL       FI_WriteDoubleWord
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD001             BEQ      ??SetPageState_10
   1620                {
   1621                  return EE_WRITE_ERROR;
   \      0x118   0x2002             MOVS     R0,#+2
   \      0x11A   0xE001             B        ??SetPageState_6
   1622                }
   1623              }
   1624              break;
   \                     ??SetPageState_10: (+1)
   \      0x11C   0xE7FF             B        ??SetPageState_7
   1625            default:
   1626              break;
   1627            }
   1628          #endif
   1629          
   1630            /* Return last operation flash status */
   1631            return EE_OK;
   \                     ??SetPageState_1: (+1)
   \                     ??SetPageState_7: (+1)
   \      0x11E   0x2000             MOVS     R0,#+0
   \                     ??SetPageState_6: (+1)
   \      0x120   0xB007             ADD      SP,SP,#+28
   \      0x122   0xBDF0             POP      {R4-R7,PC}       ;; return
   1632          }
   1633          
   1634          /**
   1635            * @brief  Get page state in page header
   1636            * @param  Address Address of the FLASH Memory page
   1637            * @retval State State of the page
   1638            */

   \                                 In section .text, align 2, keep-with-next
   1639          static EE_State_type GetPageState(uint32_t Address)
   1640          {
   \                     GetPageState: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0004             MOVS     R4,R0
   1641            EE_ELEMENT_TYPE status1 = 0U, status2 = 0U, status3 = 0U, status4 = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0xAA04             ADD      R2,SP,#+16
   \        0xC   0xC203             STM      R2!,{R0,R1}
   \        0xE   0x3A08             SUBS     R2,R2,#+8
   \       0x10   0xAA02             ADD      R2,SP,#+8
   \       0x12   0xC203             STM      R2!,{R0,R1}
   \       0x14   0x3A08             SUBS     R2,R2,#+8
   \       0x16   0x466A             MOV      R2,SP
   \       0x18   0xC203             STM      R2!,{R0,R1}
   \       0x1A   0x3A08             SUBS     R2,R2,#+8
   1642          
   1643            /* Get page state information from page header (3 first elements) */
   1644            status1 = (*(__IO EE_ELEMENT_TYPE*)Address);
   \       0x1C   0xCC0C             LDM      R4!,{R2,R3}
   \       0x1E   0x3C08             SUBS     R4,R4,#+8
   \       0x20   0xAD04             ADD      R5,SP,#+16
   \       0x22   0xC50C             STM      R5!,{R2,R3}
   \       0x24   0x3D08             SUBS     R5,R5,#+8
   1645            status2 = (*(__IO EE_ELEMENT_TYPE*)(Address + EE_ELEMENT_SIZE));
   \       0x26   0x0022             MOVS     R2,R4
   \       0x28   0x3208             ADDS     R2,R2,#+8
   \       0x2A   0xCA0C             LDM      R2,{R2,R3}
   \       0x2C   0xAD02             ADD      R5,SP,#+8
   \       0x2E   0xC50C             STM      R5!,{R2,R3}
   \       0x30   0x3D08             SUBS     R5,R5,#+8
   1646            status3 = (*(__IO EE_ELEMENT_TYPE*)(Address + (EE_ELEMENT_SIZE*2U)));
   \       0x32   0x0022             MOVS     R2,R4
   \       0x34   0x3210             ADDS     R2,R2,#+16
   \       0x36   0xCA0C             LDM      R2,{R2,R3}
   \       0x38   0x466D             MOV      R5,SP
   \       0x3A   0xC50C             STM      R5!,{R2,R3}
   \       0x3C   0x3D08             SUBS     R5,R5,#+8
   1647            status4 = (*(__IO EE_ELEMENT_TYPE*)(Address + (EE_ELEMENT_SIZE*3U)));
   \       0x3E   0x0022             MOVS     R2,R4
   \       0x40   0x3218             ADDS     R2,R2,#+24
   \       0x42   0xCA0C             LDM      R2,{R2,R3}
   \       0x44   0xAD06             ADD      R5,SP,#+24
   \       0x46   0xC50C             STM      R5!,{R2,R3}
   \       0x48   0x3D08             SUBS     R5,R5,#+8
   1648          
   1649            /* Return erasing status, if element4 is not EE_PAGESTAT_ERASED value */
   1650            if (status4 != EE_PAGESTAT_ERASED)
   \       0x4A   0xAA06             ADD      R2,SP,#+24
   \       0x4C   0xCA0C             LDM      R2,{R2,R3}
   \       0x4E   0x....             ADR      R6,??DataTable20_10
   \       0x50   0xCEC0             LDM      R6,{R6,R7}
   \       0x52   0x42BB             CMP      R3,R7
   \       0x54   0xD101             BNE      ??GetPageState_0
   \       0x56   0x42B2             CMP      R2,R6
   \       0x58   0xD001             BEQ      ??GetPageState_1
   1651            {
   1652              return STATE_PAGE_ERASING;
   \                     ??GetPageState_0: (+1)
   \       0x5A   0x2004             MOVS     R0,#+4
   \       0x5C   0xE01E             B        ??GetPageState_2
   1653            }
   1654          
   1655            /* Return valid status, if element3 is not EE_PAGESTAT_ERASED value */
   1656            if (status3 != EE_PAGESTAT_ERASED)
   \                     ??GetPageState_1: (+1)
   \       0x5E   0x4668             MOV      R0,SP
   \       0x60   0xC803             LDM      R0,{R0,R1}
   \       0x62   0x....             ADR      R2,??DataTable20_10
   \       0x64   0xCA0C             LDM      R2,{R2,R3}
   \       0x66   0x4299             CMP      R1,R3
   \       0x68   0xD101             BNE      ??GetPageState_3
   \       0x6A   0x4290             CMP      R0,R2
   \       0x6C   0xD001             BEQ      ??GetPageState_4
   1657            {
   1658              return STATE_PAGE_VALID;
   \                     ??GetPageState_3: (+1)
   \       0x6E   0x2003             MOVS     R0,#+3
   \       0x70   0xE014             B        ??GetPageState_2
   1659            }
   1660          
   1661            /* Return active status, if element2 is not EE_PAGESTAT_ERASED value */
   1662            if (status2 != EE_PAGESTAT_ERASED)
   \                     ??GetPageState_4: (+1)
   \       0x72   0xA802             ADD      R0,SP,#+8
   \       0x74   0xC803             LDM      R0,{R0,R1}
   \       0x76   0x....             ADR      R2,??DataTable20_10
   \       0x78   0xCA0C             LDM      R2,{R2,R3}
   \       0x7A   0x4299             CMP      R1,R3
   \       0x7C   0xD101             BNE      ??GetPageState_5
   \       0x7E   0x4290             CMP      R0,R2
   \       0x80   0xD001             BEQ      ??GetPageState_6
   1663            {
   1664              return STATE_PAGE_ACTIVE;
   \                     ??GetPageState_5: (+1)
   \       0x82   0x2002             MOVS     R0,#+2
   \       0x84   0xE00A             B        ??GetPageState_2
   1665            }
   1666          
   1667            /* Return receive status, if element1 is not EE_PAGESTAT_ERASED value */
   1668            if (status1 != EE_PAGESTAT_ERASED)
   \                     ??GetPageState_6: (+1)
   \       0x86   0xA804             ADD      R0,SP,#+16
   \       0x88   0xC803             LDM      R0,{R0,R1}
   \       0x8A   0x....             ADR      R2,??DataTable20_10
   \       0x8C   0xCA0C             LDM      R2,{R2,R3}
   \       0x8E   0x4299             CMP      R1,R3
   \       0x90   0xD101             BNE      ??GetPageState_7
   \       0x92   0x4290             CMP      R0,R2
   \       0x94   0xD001             BEQ      ??GetPageState_8
   1669            {
   1670              return STATE_PAGE_RECEIVE;
   \                     ??GetPageState_7: (+1)
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE000             B        ??GetPageState_2
   1671            }
   1672          
   1673            /* Return erased status, if 4 first elements are EE_PAGESTAT_ERASED value */
   1674            return STATE_PAGE_ERASED;
   \                     ??GetPageState_8: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??GetPageState_2: (+1)
   \       0x9C   0xB009             ADD      SP,SP,#+36
   \       0x9E   0xBDF0             POP      {R4-R7,PC}       ;; return
   1675          }
   1676          
   1677          /**
   1678            * @brief  This function configures CRC Instance.
   1679            * @note   This function is used to :
   1680            *         -1- Enable peripheral clock for CRC.
   1681            *         -2- Configure CRC functional parameters.
   1682            * @note   Peripheral configuration is minimal configuration from reset values.
   1683            *         Thus, some useless LL unitary functions calls below are provided as
   1684            *         commented examples - setting is default configuration from reset.
   1685            * @param  None
   1686            * @retval None
   1687            */

   \                                 In section .text, align 2, keep-with-next
   1688          void ConfigureCrc(void)
   1689          {
   \                     ConfigureCrc: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1690            /* (1) Enable peripheral clock for CRC */
   1691            LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_CRC);
   \        0x2   0x2080             MOVS     R0,#+128
   \        0x4   0x0140             LSLS     R0,R0,#+5        ;; #+4096
   \        0x6   0x....'....        BL       LL_AHB1_GRP1_EnableClock
   1692          
   1693            /* (2) Configure CRC functional parameters */
   1694          
   1695            /* Configure CRC calculation unit with user defined polynomial */
   1696            LL_CRC_SetPolynomialCoef(CRC, CRC_POLYNOMIAL_VALUE);
   \        0xA   0x....             LDR      R4,??DataTable20_7  ;; 0x40023000
   \        0xC   0x....             LDR      R1,??DataTable20_11  ;; 0x8005
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x....'....        BL       LL_CRC_SetPolynomialCoef
   1697            LL_CRC_SetPolynomialSize(CRC, CRC_POLYNOMIAL_LENGTH);
   \       0x14   0x2108             MOVS     R1,#+8
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       LL_CRC_SetPolynomialSize
   1698          
   1699            /* Initialize default CRC initial value */
   1700            /* Reset value is LL_CRC_DEFAULT_CRC_INITVALUE */
   1701            /* LL_CRC_SetInitialData(CRC, LL_CRC_DEFAULT_CRC_INITVALUE);*/
   1702          
   1703            /* Set input data inversion mode : No inversion*/
   1704            /* Reset value is LL_CRC_INDATA_REVERSE_NONE */
   1705            /* LL_CRC_SetInputDataReverseMode(CRC, LL_CRC_INDATA_REVERSE_NONE); */
   1706          
   1707            /* Set output data inversion mode : No inversion */
   1708            /* Reset value is LL_CRC_OUTDATA_REVERSE_NONE */
   1709            /* LL_CRC_SetOutputDataReverseMode(CRC, LL_CRC_OUTDATA_REVERSE_NONE); */
   1710          }
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
   1711          
   1712          /**
   1713            * @brief  This function performs CRC calculation on Data and Virtual Address.
   1714            * @param  Data value of  the eeprom variable.
   1715            * @param  VirtAddress address of the eeprom variable.
   1716            * @retval 16-bit CRC value computed on Data and Virtual Address.
   1717            */

   \                                 In section .text, align 2, keep-with-next
   1718          uint16_t CalculateCrc(EE_DATA_TYPE Data, uint16_t VirtAddress)
   1719          {
   \                     CalculateCrc: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   1720            /* Reset CRC calculation unit */
   1721            LL_CRC_ResetCRCCalculationUnit(CRC);
   \        0x6   0x....             LDR      R5,??DataTable20_7  ;; 0x40023000
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x....'....        BL       LL_CRC_ResetCRCCalculationUnit
   1722          
   1723            /* Feed Data and Virtual Address */
   1724            LL_CRC_FeedData32(CRC, Data);
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x....'....        BL       LL_CRC_FeedData32
   1725            LL_CRC_FeedData16(CRC, VirtAddress);
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0xB289             UXTH     R1,R1
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x....'....        BL       LL_CRC_FeedData16
   1726          
   1727            /* Return computed CRC value */
   1728            return(LL_CRC_ReadData16(CRC));
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x....'....        BL       LL_CRC_ReadData16
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
   1729          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x4002'1038        DC32     0x40021038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     uhNbWrittenElements

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     uwAddressNextWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFFFFFF

   \              0xFFFF'FFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     ubCurrentActivePage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x1FFF'75E0        DC32     0x1fff75e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x1FFF'75E0        DC32     0x1fff75e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFFFFFF

   \              0xFFFF'FFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     ubCurrentActivePage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x1FFF'75E0        DC32     0x1fff75e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     uwAddressNextWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     uhNbWrittenElements

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     ubCurrentActivePage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     uwAddressNextWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x1FFF'75E0        DC32     0x1fff75e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFFFFFF

   \              0xFFFF'FFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x0000'03E9        DC32     0x3e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     uhNbWrittenElements

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x0000'04EC        DC32     0x4ec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x1FFF'75E0        DC32     0x1fff75e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x0800'0008        DC32     0x8000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0x0800'0010        DC32     0x8000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0x0800'0018        DC32     0x8000018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0x....'....        DC32     ubCurrentActivePage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \        0x0   0x4002'3000        DC32     0x40023000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \        0x0   0x....'....        DC32     uwAddressNextWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \        0x0   0xAAAA'AAAA        DC32     0xAAAAAAAA,0xAAAAAAAA

   \              0xAAAA'AAAA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFFFFFF

   \              0xFFFF'FFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \        0x0   0x0000'8005        DC32     0x8005
   1730          
   1731          /**
   1732            * @}
   1733            */
   1734          
   1735          /**
   1736            * @}
   1737            */
   1738          
   1739          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CalculateCrc
        16   -> LL_CRC_FeedData16
        16   -> LL_CRC_FeedData32
        16   -> LL_CRC_ReadData16
        16   -> LL_CRC_ResetCRCCalculationUnit
       8   ConfigureCrc
         8   -> LL_AHB1_GRP1_EnableClock
         8   -> LL_CRC_SetPolynomialCoef
         8   -> LL_CRC_SetPolynomialSize
      40   EE_CleanUp
        40   -> FI_CacheFlush
        40   -> FI_PageErase
        40   -> GetPageState
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      40   EE_CleanUp_IT
        40   -> FI_CacheFlush
        40   -> FI_PageErase_IT
        40   -> GetPageState
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
       8   EE_DeleteCorruptedFlashAddress
         8   -> FI_DeleteCorruptedFlashAddress
       0   EE_EndOfCleanup_UserCallback
      32   EE_Format
        32   -> FI_CacheFlush
        32   -> FI_CheckBankConfig
        32   -> FI_PageErase
        32   -> SetPageState
        32   -> VerifyPageFullyErased
        32 __aeabi_uidiv
        32 __aeabi_uidivmod
      80   EE_Init
        80   -> ConfigureCrc
        80   -> EE_Format
        80   -> FI_CacheFlush
        80   -> FI_CheckBankConfig
        80   -> FI_PageErase
        80   -> GetPageState
        80   -> PagesTransfer
        80   -> SetPageState
        80   -> VerifyPageFullyErased
        80   -> VerifyPagesFullWriteVariable
        80 __aeabi_uidiv
        80 __aeabi_uidivmod
      24   EE_ReadVariable16bits
        24   -> ReadVariable
      24   EE_ReadVariable32bits
        24   -> ReadVariable
      24   EE_ReadVariable8bits
        24   -> ReadVariable
      16   EE_WriteVariable16bits
        16   -> WriteVariable
      16   EE_WriteVariable32bits
        16   -> WriteVariable
      16   EE_WriteVariable8bits
        16   -> WriteVariable
      40   FindPage
        40   -> EE_CleanUp
        40   -> GetPageState
        40   -> SetPageState
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      56   GetPageState
       4   LL_AHB1_GRP1_EnableClock
       0   LL_CRC_FeedData16
       0   LL_CRC_FeedData32
       0   LL_CRC_ReadData16
       0   LL_CRC_ResetCRCCalculationUnit
       0   LL_CRC_SetPolynomialCoef
       0   LL_CRC_SetPolynomialSize
      64   PagesTransfer
        64   -> FindPage
        64   -> GetPageState
        64   -> ReadVariable
        64   -> SetPageState
        64   -> VerifyPagesFullWriteVariable
        64 __aeabi_uidiv
        64 __aeabi_uidivmod
      48   ReadVariable
        48   -> CalculateCrc
        48   -> FindPage
        48   -> GetPageState
        48 __aeabi_uidiv
        48 __aeabi_uidivmod
      48   SetPageState
        48   -> FI_WriteDoubleWord
        48 __aeabi_uidiv
      20   VerifyPageFullyErased
      48   VerifyPagesFullWriteVariable
        48   -> CalculateCrc
        48   -> FI_WriteDoubleWord
        48   -> FindPage
        48 __aeabi_uidiv
      24   WriteVariable
        24   -> PagesTransfer
        24   -> VerifyPagesFullWriteVariable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable13
       8  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       8  ??DataTable16
       4  ??DataTable17
       4  ??DataTable20
       4  ??DataTable20_1
       8  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       8  ??DataTable20_9
       4  ??DataTable3
       4  ??DataTable3_1
       8  ??DataTable4
       4  ??DataTable5
       4  AddressRead
      40  CalculateCrc
       1  CleanupPhase
      30  ConfigureCrc
     246  EE_CleanUp
     246  EE_CleanUp_IT
      12  EE_DeleteCorruptedFlashAddress
       2  EE_EndOfCleanup_UserCallback
     230  EE_Format
   2'052  EE_Init
      50  EE_ReadVariable16bits
      50  EE_ReadVariable32bits
      50  EE_ReadVariable8bits
      42  EE_WriteVariable16bits
      40  EE_WriteVariable32bits
      42  EE_WriteVariable8bits
     478  FindPage
     160  GetPageState
      22  LL_AHB1_GRP1_EnableClock
       6  LL_CRC_FeedData16
       4  LL_CRC_FeedData32
       6  LL_CRC_ReadData16
      10  LL_CRC_ResetCRCCalculationUnit
       4  LL_CRC_SetPolynomialCoef
      12  LL_CRC_SetPolynomialSize
     900  PagesTransfer
     348  ReadVariable
     292  SetPageState
      44  VerifyPageFullyErased
     170  VerifyPagesFullWriteVariable
      48  WriteVariable
       1  ubCurrentActivePage
       2  uhNbWrittenElements
       4  uwAddressNextWrite

 
     8 bytes in section .bss
     4 bytes in section .data
 5'776 bytes in section .text
 
 5'774 bytes of CODE memory (+ 2 bytes shared)
    12 bytes of DATA memory

Errors: none
Warnings: none
